\begin{Verbatim}[commandchars=\\\{\}]
    \PYG{k+kn}{from}\PYG{+w}{ }\PYG{n+nn}{\PYGZus{}\PYGZus{}future\PYGZus{}\PYGZus{}}\PYG{+w}{ }\PYG{k+kn}{import} \PYG{n}{annotations}
    \PYG{k+kn}{from}\PYG{+w}{ }\PYG{n+nn}{abc}\PYG{+w}{ }\PYG{k+kn}{import} \PYG{n}{ABC}
    \PYG{k+kn}{import}\PYG{+w}{ }\PYG{n+nn}{contextlib}

    \PYG{k+kn}{import}\PYG{+w}{ }\PYG{n+nn}{numpy}\PYG{+w}{ }\PYG{k}{as}\PYG{+w}{ }\PYG{n+nn}{np}

    \PYG{k+kn}{from}\PYG{+w}{ }\PYG{n+nn}{nea.ml.autograd.consts}\PYG{+w}{ }\PYG{k+kn}{import} \PYG{n}{Tensorable}
    \PYG{k+kn}{from}\PYG{+w}{ }\PYG{n+nn}{nea.ml.autograd.convolve\PYGZus{}funcs}\PYG{+w}{ }\PYG{k+kn}{import} \PYG{p}{(}
        \PYG{n}{cpu\PYGZus{}forward\PYGZus{}convolve2d}\PYG{p}{,}
        \PYG{n}{cpu\PYGZus{}k\PYGZus{}backward\PYGZus{}convolve2d}\PYG{p}{,}
        \PYG{n}{cpu\PYGZus{}x\PYGZus{}backward\PYGZus{}convolve2d}\PYG{p}{,}
        \PYG{n}{cpu\PYGZus{}x\PYGZus{}and\PYGZus{}k\PYGZus{}backward\PYGZus{}convolve2d}\PYG{p}{,}
    \PYG{p}{)}
    \PYG{k+kn}{from}\PYG{+w}{ }\PYG{n+nn}{nea.ml.autograd.jit\PYGZus{}functions}\PYG{+w}{ }\PYG{k+kn}{import} \PYG{n}{fill\PYGZus{}padded\PYGZus{}array}

    \PYG{c+c1}{\PYGZsh{} ========}
    \PYG{c+c1}{\PYGZsh{}  TENSOR}
    \PYG{c+c1}{\PYGZsh{} ========}

    \PYG{n}{\PYGZus{}grad\PYGZus{}is\PYGZus{}enabled} \PYG{o}{=} \PYG{k+kc}{True}


    \PYG{k}{def}\PYG{+w}{ }\PYG{n+nf}{is\PYGZus{}grad\PYGZus{}enabled}\PYG{p}{()} \PYG{o}{\PYGZhy{}\PYGZgt{}} \PYG{n+nb}{bool}\PYG{p}{:}
\PYG{+w}{        }\PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}Returns if gradient calculations are enabled}

\PYG{l+s+sd}{        Returns:}
\PYG{l+s+sd}{            bool:}
\PYG{l+s+sd}{        \PYGZdq{}\PYGZdq{}\PYGZdq{}}
        \PYG{k}{return} \PYG{n}{\PYGZus{}grad\PYGZus{}is\PYGZus{}enabled}


    \PYG{n+nd}{@contextlib}\PYG{o}{.}\PYG{n}{contextmanager}
    \PYG{k}{def}\PYG{+w}{ }\PYG{n+nf}{no\PYGZus{}grad}\PYG{p}{():}
\PYG{+w}{        }\PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}context manager to disable gradient calculations\PYGZdq{}\PYGZdq{}\PYGZdq{}}
        \PYG{k}{global} \PYG{n}{\PYGZus{}grad\PYGZus{}is\PYGZus{}enabled}
        \PYG{n}{prev\PYGZus{}state} \PYG{o}{=} \PYG{n}{\PYGZus{}grad\PYGZus{}is\PYGZus{}enabled}
        \PYG{n}{\PYGZus{}grad\PYGZus{}is\PYGZus{}enabled} \PYG{o}{=} \PYG{k+kc}{False}  \PYG{c+c1}{\PYGZsh{} Disable gradients}
        \PYG{k}{try}\PYG{p}{:}
            \PYG{k}{yield}
        \PYG{k}{finally}\PYG{p}{:}
            \PYG{n}{\PYGZus{}grad\PYGZus{}is\PYGZus{}enabled} \PYG{o}{=} \PYG{n}{prev\PYGZus{}state}  \PYG{c+c1}{\PYGZsh{} return to previous}


    \PYG{k}{class}\PYG{+w}{ }\PYG{n+nc}{Tensor}\PYG{p}{:}
\PYG{+w}{        }\PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}}
\PYG{l+s+sd}{        ====================}
\PYG{l+s+sd}{            Tensor class}
\PYG{l+s+sd}{        ====================}
\PYG{l+s+sd}{        \PYGZdq{}\PYGZdq{}\PYGZdq{}}

        \PYG{k}{def}\PYG{+w}{ }\PYG{n+nf+fm}{\PYGZus{}\PYGZus{}init\PYGZus{}\PYGZus{}}\PYG{p}{(}
            \PYG{n+nb+bp}{self}\PYG{p}{,}
            \PYG{n}{data}\PYG{p}{:} \PYG{n}{Tensorable}\PYG{p}{,}
            \PYG{n}{requires\PYGZus{}grad}\PYG{p}{:} \PYG{n+nb}{bool} \PYG{o}{=} \PYG{k+kc}{False}\PYG{p}{,}
            \PYG{n}{operation}\PYG{p}{:} \PYG{n}{TensorFunction} \PYG{o}{=} \PYG{k+kc}{None}\PYG{p}{,}
        \PYG{p}{)} \PYG{o}{\PYGZhy{}\PYGZgt{}} \PYG{k+kc}{None}\PYG{p}{:}
            \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{\PYGZus{}data}\PYG{p}{:} \PYG{n}{np}\PYG{o}{.}\PYG{n}{ndarray} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{n}{data}\PYG{p}{)}
            \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{shape} \PYG{o}{=} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{\PYGZus{}data}\PYG{o}{.}\PYG{n}{shape}
            \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{operation}\PYG{p}{:} \PYG{n}{TensorFunction} \PYG{o}{=} \PYG{n}{operation}

            \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{requires\PYGZus{}grad}\PYG{p}{:} \PYG{n+nb}{bool} \PYG{o}{=} \PYG{n}{requires\PYGZus{}grad}

            \PYG{k}{if} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{requires\PYGZus{}grad}\PYG{p}{:}
                \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{grad} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{zeros\PYGZus{}like}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{\PYGZus{}data}\PYG{p}{)}

            \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{children} \PYG{o}{=} \PYG{p}{[]}

        \PYG{k}{def}\PYG{+w}{ }\PYG{n+nf+fm}{\PYGZus{}\PYGZus{}repr\PYGZus{}\PYGZus{}}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{)} \PYG{o}{\PYGZhy{}\PYGZgt{}} \PYG{n+nb}{str}\PYG{p}{:}
            \PYG{k}{return} \PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}Tensor(}\PYG{l+s+si}{\PYGZob{}}\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{\PYGZus{}data}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{, shape = }\PYG{l+s+si}{\PYGZob{}}\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{shape}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{)\PYGZdq{}}

        \PYG{n+nd}{@staticmethod}
        \PYG{k}{def}\PYG{+w}{ }\PYG{n+nf}{zeros}\PYG{p}{(}\PYG{n}{shape}\PYG{p}{:} \PYG{n+nb}{tuple}\PYG{p}{[}\PYG{n+nb}{int}\PYG{p}{],} \PYG{n}{requires\PYGZus{}grad}\PYG{p}{:} \PYG{n+nb}{bool} \PYG{o}{=} \PYG{k+kc}{False}\PYG{p}{)} \PYG{o}{\PYGZhy{}\PYGZgt{}} \PYG{n}{Tensor}\PYG{p}{:}
\PYG{+w}{            }\PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}Returns a tensor of 1s}

\PYG{l+s+sd}{            Args:}
\PYG{l+s+sd}{                shape (tuple[int]): desired shape of tensor}
\PYG{l+s+sd}{                requires\PYGZus{}grad (bool, optional): if the tensors requires\PYGZus{}grad property should be false.}
\PYG{l+s+sd}{                Defaults to False.}

\PYG{l+s+sd}{            Returns:}
\PYG{l+s+sd}{                Tensor: tensor of 1s}
\PYG{l+s+sd}{            \PYGZdq{}\PYGZdq{}\PYGZdq{}}
            \PYG{k}{return} \PYG{n}{Tensor}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{zeros}\PYG{p}{(}\PYG{n}{shape}\PYG{p}{),} \PYG{n}{requires\PYGZus{}grad}\PYG{o}{=}\PYG{n}{requires\PYGZus{}grad}\PYG{p}{)}

        \PYG{n+nd}{@staticmethod}
        \PYG{k}{def}\PYG{+w}{ }\PYG{n+nf}{ones}\PYG{p}{(}\PYG{n}{shape}\PYG{p}{:} \PYG{n+nb}{tuple}\PYG{p}{[}\PYG{n+nb}{int}\PYG{p}{],} \PYG{n}{requries\PYGZus{}grad}\PYG{p}{:} \PYG{n+nb}{bool} \PYG{o}{=} \PYG{k+kc}{False}\PYG{p}{)} \PYG{o}{\PYGZhy{}\PYGZgt{}} \PYG{n}{Tensor}\PYG{p}{:}
\PYG{+w}{            }\PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}Returns a tensor of 0s}

\PYG{l+s+sd}{            Args:}
\PYG{l+s+sd}{                shape (tuple[int]): desired shape of tensor}
\PYG{l+s+sd}{                requires\PYGZus{}grad (bool, optional): if the tensors requires\PYGZus{}grad property should be false.}
\PYG{l+s+sd}{                Defaults to False.}

\PYG{l+s+sd}{            Returns:}
\PYG{l+s+sd}{                Tensor: tensor of 0s}
\PYG{l+s+sd}{            \PYGZdq{}\PYGZdq{}\PYGZdq{}}
            \PYG{k}{return} \PYG{n}{Tensor}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{ones}\PYG{p}{(}\PYG{n}{shape}\PYG{p}{),} \PYG{n}{requires\PYGZus{}grad}\PYG{o}{=}\PYG{n}{requries\PYGZus{}grad}\PYG{p}{)}

        \PYG{k}{def}\PYG{+w}{ }\PYG{n+nf}{backward}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{dy}\PYG{o}{=}\PYG{k+kc}{None}\PYG{p}{,} \PYG{n}{y}\PYG{o}{=}\PYG{k+kc}{None}\PYG{p}{)} \PYG{o}{\PYGZhy{}\PYGZgt{}} \PYG{k+kc}{None}\PYG{p}{:}
\PYG{+w}{            }\PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}Reverse searches the computational graph, computing and updating parent}
\PYG{l+s+sd}{            gradients as it goes}

\PYG{l+s+sd}{            Args:}
\PYG{l+s+sd}{                dy (Tensor, optional): \PYGZus{}description\PYGZus{}. Defaults to None.}
\PYG{l+s+sd}{                y (Tensor, optional): \PYGZus{}description\PYGZus{}. Defaults to None.}

\PYG{l+s+sd}{            Returns:}
\PYG{l+s+sd}{                None}
\PYG{l+s+sd}{            \PYGZdq{}\PYGZdq{}\PYGZdq{}}
            \PYG{k}{if} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{requires\PYGZus{}grad} \PYG{o+ow}{is} \PYG{k+kc}{False}\PYG{p}{:}
                \PYG{k}{raise} \PYG{n+ne}{ValueError}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}Tensor has requires grad set to false\PYGZdq{}}\PYG{p}{)}
            \PYG{k}{if} \PYG{o+ow}{not} \PYG{n}{is\PYGZus{}grad\PYGZus{}enabled}\PYG{p}{():}
                \PYG{k}{raise} \PYG{n+ne}{ValueError}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}no\PYGZus{}grad is enabled\PYGZdq{}}\PYG{p}{)}

            \PYG{k}{if} \PYG{n}{dy} \PYG{o+ow}{is} \PYG{k+kc}{None}\PYG{p}{:} \PYG{c+c1}{\PYGZsh{} if no upstream gradient}
                \PYG{n}{dy} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{ones\PYGZus{}like}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{\PYGZus{}data}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} derivative of itself is 1}

            \PYG{k}{if} \PYG{n}{y} \PYG{o+ow}{is} \PYG{o+ow}{not} \PYG{k+kc}{None}\PYG{p}{:}
                \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{children}\PYG{o}{.}\PYG{n}{remove}\PYG{p}{(}\PYG{n}{y}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} remove from graph to stop duplicate calculation}

            \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{grad} \PYG{o}{=} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{grad} \PYG{o}{+} \PYG{n}{dy} \PYG{c+c1}{\PYGZsh{} accumulate grad}

            \PYG{k}{if} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{operation}\PYG{p}{:}
                \PYG{k}{if} \PYG{o+ow}{not} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{children}\PYG{p}{:} \PYG{c+c1}{\PYGZsh{} continue traversing up graph}
                    \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{operation}\PYG{o}{.}\PYG{n}{backward}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{grad}\PYG{p}{,} \PYG{n+nb+bp}{self}\PYG{p}{)}

        \PYG{k}{def}\PYG{+w}{ }\PYG{n+nf}{zero\PYGZus{}grad}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{)} \PYG{o}{\PYGZhy{}\PYGZgt{}} \PYG{k+kc}{None}\PYG{p}{:}
\PYG{+w}{            }\PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}}
\PYG{l+s+sd}{            Zeros out the gradient of the tensor}
\PYG{l+s+sd}{            \PYGZdq{}\PYGZdq{}\PYGZdq{}}
            \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{grad} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{zeros\PYGZus{}like}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{\PYGZus{}data}\PYG{p}{)}

        \PYG{k}{def}\PYG{+w}{ }\PYG{n+nf+fm}{\PYGZus{}\PYGZus{}eq\PYGZus{}\PYGZus{}}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{other}\PYG{p}{:} \PYG{n}{np}\PYG{o}{.}\PYG{n}{ndarray} \PYG{o}{|} \PYG{n+nb}{int} \PYG{o}{|} \PYG{n+nb}{float}\PYG{p}{):}
            \PYG{k}{if} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array\PYGZus{}equal}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{data}\PYG{p}{,} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{n}{other}\PYG{p}{)):}
                \PYG{k}{return} \PYG{k+kc}{True}

        \PYG{k}{def}\PYG{+w}{ }\PYG{n+nf+fm}{\PYGZus{}\PYGZus{}add\PYGZus{}\PYGZus{}}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{other}\PYG{p}{:} \PYG{n}{Tensorable}\PYG{p}{)} \PYG{o}{\PYGZhy{}\PYGZgt{}} \PYG{n}{Tensor}\PYG{p}{:}
            \PYG{n}{add\PYGZus{}op} \PYG{o}{=} \PYG{n}{Addition}\PYG{p}{()}
            \PYG{k}{return} \PYG{n}{add\PYGZus{}op}\PYG{o}{.}\PYG{n}{forward}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{to\PYGZus{}tensor}\PYG{p}{(}\PYG{n}{other}\PYG{p}{))}

        \PYG{k}{def}\PYG{+w}{ }\PYG{n+nf+fm}{\PYGZus{}\PYGZus{}radd\PYGZus{}\PYGZus{}}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{other}\PYG{p}{:} \PYG{n}{Tensorable}\PYG{p}{)} \PYG{o}{\PYGZhy{}\PYGZgt{}} \PYG{n}{Tensor}\PYG{p}{:}
            \PYG{n}{add\PYGZus{}op} \PYG{o}{=} \PYG{n}{Addition}\PYG{p}{()}
            \PYG{k}{return} \PYG{n}{add\PYGZus{}op}\PYG{o}{.}\PYG{n}{forward}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{to\PYGZus{}tensor}\PYG{p}{(}\PYG{n}{other}\PYG{p}{))}

        \PYG{k}{def}\PYG{+w}{ }\PYG{n+nf+fm}{\PYGZus{}\PYGZus{}iadd\PYGZus{}\PYGZus{}}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{other}\PYG{p}{:} \PYG{n}{Tensorable}\PYG{p}{)} \PYG{o}{\PYGZhy{}\PYGZgt{}} \PYG{n}{Tensor}\PYG{p}{:}
            \PYG{n}{add\PYGZus{}op} \PYG{o}{=} \PYG{n}{Addition}\PYG{p}{()}
            \PYG{k}{return} \PYG{n}{add\PYGZus{}op}\PYG{o}{.}\PYG{n}{forward}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{to\PYGZus{}tensor}\PYG{p}{(}\PYG{n}{other}\PYG{p}{))}

        \PYG{k}{def}\PYG{+w}{ }\PYG{n+nf+fm}{\PYGZus{}\PYGZus{}neg\PYGZus{}\PYGZus{}}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{):}
            \PYG{n}{neg\PYGZus{}op} \PYG{o}{=} \PYG{n}{Negation}\PYG{p}{()}
            \PYG{k}{return} \PYG{n}{neg\PYGZus{}op}\PYG{o}{.}\PYG{n}{forward}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{)}

        \PYG{k}{def}\PYG{+w}{ }\PYG{n+nf+fm}{\PYGZus{}\PYGZus{}sub\PYGZus{}\PYGZus{}}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{other}\PYG{p}{:} \PYG{n}{Tensorable}\PYG{p}{)} \PYG{o}{\PYGZhy{}\PYGZgt{}} \PYG{n}{Tensor}\PYG{p}{:}
            \PYG{k}{return} \PYG{n+nb+bp}{self} \PYG{o}{+} \PYG{o}{\PYGZhy{}}\PYG{n}{to\PYGZus{}tensor}\PYG{p}{(}\PYG{n}{other}\PYG{p}{)}

        \PYG{k}{def}\PYG{+w}{ }\PYG{n+nf+fm}{\PYGZus{}\PYGZus{}rsub\PYGZus{}\PYGZus{}}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{other}\PYG{p}{:} \PYG{n}{Tensorable}\PYG{p}{)} \PYG{o}{\PYGZhy{}\PYGZgt{}} \PYG{n}{Tensor}\PYG{p}{:}
            \PYG{k}{return} \PYG{n}{to\PYGZus{}tensor}\PYG{p}{(}\PYG{n}{other}\PYG{p}{)} \PYG{o}{+} \PYG{o}{\PYGZhy{}}\PYG{n+nb+bp}{self}

        \PYG{k}{def}\PYG{+w}{ }\PYG{n+nf+fm}{\PYGZus{}\PYGZus{}isub\PYGZus{}\PYGZus{}}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{other}\PYG{p}{:} \PYG{n}{Tensorable}\PYG{p}{)} \PYG{o}{\PYGZhy{}\PYGZgt{}} \PYG{n}{Tensor}\PYG{p}{:}
            \PYG{k}{return} \PYG{n+nb+bp}{self} \PYG{o}{+} \PYG{o}{\PYGZhy{}}\PYG{n}{to\PYGZus{}tensor}\PYG{p}{(}\PYG{n}{other}\PYG{p}{)}

        \PYG{k}{def}\PYG{+w}{ }\PYG{n+nf+fm}{\PYGZus{}\PYGZus{}mul\PYGZus{}\PYGZus{}}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{other}\PYG{p}{:} \PYG{n}{Tensorable}\PYG{p}{)} \PYG{o}{\PYGZhy{}\PYGZgt{}} \PYG{n}{Tensor}\PYG{p}{:}
            \PYG{n}{mul\PYGZus{}op} \PYG{o}{=} \PYG{n}{Multiplication}\PYG{p}{()}
            \PYG{k}{return} \PYG{n}{mul\PYGZus{}op}\PYG{o}{.}\PYG{n}{forward}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{to\PYGZus{}tensor}\PYG{p}{(}\PYG{n}{other}\PYG{p}{))}

        \PYG{k}{def}\PYG{+w}{ }\PYG{n+nf+fm}{\PYGZus{}\PYGZus{}rmul\PYGZus{}\PYGZus{}}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{other}\PYG{p}{:} \PYG{n}{Tensorable}\PYG{p}{)} \PYG{o}{\PYGZhy{}\PYGZgt{}} \PYG{n}{Tensor}\PYG{p}{:}
            \PYG{n}{mul\PYGZus{}op} \PYG{o}{=} \PYG{n}{Multiplication}\PYG{p}{()}
            \PYG{k}{return} \PYG{n}{mul\PYGZus{}op}\PYG{o}{.}\PYG{n}{forward}\PYG{p}{(}\PYG{n}{to\PYGZus{}tensor}\PYG{p}{(}\PYG{n}{other}\PYG{p}{),} \PYG{n+nb+bp}{self}\PYG{p}{)}

        \PYG{k}{def}\PYG{+w}{ }\PYG{n+nf+fm}{\PYGZus{}\PYGZus{}imul\PYGZus{}\PYGZus{}}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{other}\PYG{p}{:} \PYG{n}{Tensorable}\PYG{p}{)} \PYG{o}{\PYGZhy{}\PYGZgt{}} \PYG{n}{Tensor}\PYG{p}{:}
            \PYG{n}{mul\PYGZus{}op} \PYG{o}{=} \PYG{n}{Multiplication}\PYG{p}{()}
            \PYG{k}{return} \PYG{n}{mul\PYGZus{}op}\PYG{o}{.}\PYG{n}{forward}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{to\PYGZus{}tensor}\PYG{p}{(}\PYG{n}{other}\PYG{p}{))}

        \PYG{k}{def}\PYG{+w}{ }\PYG{n+nf+fm}{\PYGZus{}\PYGZus{}truediv\PYGZus{}\PYGZus{}}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{other}\PYG{p}{:} \PYG{n}{Tensorable}\PYG{p}{)} \PYG{o}{\PYGZhy{}\PYGZgt{}} \PYG{n}{Tensor}\PYG{p}{:}
            \PYG{n}{div\PYGZus{}op} \PYG{o}{=} \PYG{n}{Division}\PYG{p}{()}
            \PYG{k}{return} \PYG{n}{div\PYGZus{}op}\PYG{o}{.}\PYG{n}{forward}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{to\PYGZus{}tensor}\PYG{p}{(}\PYG{n}{other}\PYG{p}{))}

        \PYG{k}{def}\PYG{+w}{ }\PYG{n+nf+fm}{\PYGZus{}\PYGZus{}matmul\PYGZus{}\PYGZus{}}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{other}\PYG{p}{:} \PYG{n}{Tensorable}\PYG{p}{)} \PYG{o}{\PYGZhy{}\PYGZgt{}} \PYG{n}{Tensor}\PYG{p}{:}
            \PYG{n}{matmul\PYGZus{}op} \PYG{o}{=} \PYG{n}{MatrixMultiplication}\PYG{p}{()}
            \PYG{k}{return} \PYG{n}{matmul\PYGZus{}op}\PYG{o}{.}\PYG{n}{forward}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{to\PYGZus{}tensor}\PYG{p}{(}\PYG{n}{other}\PYG{p}{))}

        \PYG{k}{def}\PYG{+w}{ }\PYG{n+nf+fm}{\PYGZus{}\PYGZus{}pow\PYGZus{}\PYGZus{}}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{other}\PYG{p}{:} \PYG{n}{Tensorable}\PYG{p}{)} \PYG{o}{\PYGZhy{}\PYGZgt{}} \PYG{n}{Tensor}\PYG{p}{:}
            \PYG{n}{pow\PYGZus{}op} \PYG{o}{=} \PYG{n}{Power}\PYG{p}{()}
            \PYG{k}{return} \PYG{n}{pow\PYGZus{}op}\PYG{o}{.}\PYG{n}{forward}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{to\PYGZus{}tensor}\PYG{p}{(}\PYG{n}{other}\PYG{p}{))}

        \PYG{k}{def}\PYG{+w}{ }\PYG{n+nf}{T}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{)} \PYG{o}{\PYGZhy{}\PYGZgt{}} \PYG{n}{Tensor}\PYG{p}{:}
\PYG{+w}{            }\PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}Returns a copy of the tensor, however the data has been transposed}

\PYG{l+s+sd}{            Returns:}
\PYG{l+s+sd}{                Tensor:}
\PYG{l+s+sd}{            \PYGZdq{}\PYGZdq{}\PYGZdq{}}
            \PYG{n}{transpose\PYGZus{}op} \PYG{o}{=} \PYG{n}{Transpose}\PYG{p}{()}
            \PYG{k}{return} \PYG{n}{transpose\PYGZus{}op}\PYG{o}{.}\PYG{n}{forward}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{)}

        \PYG{k}{def}\PYG{+w}{ }\PYG{n+nf}{mean}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{)} \PYG{o}{\PYGZhy{}\PYGZgt{}} \PYG{n}{Tensor}\PYG{p}{:}
\PYG{+w}{            }\PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}Computes the mean of the tensor}

\PYG{l+s+sd}{            Returns:}
\PYG{l+s+sd}{                Tensor: \PYGZus{}description\PYGZus{}}
\PYG{l+s+sd}{            \PYGZdq{}\PYGZdq{}\PYGZdq{}}
            \PYG{n}{mean\PYGZus{}op} \PYG{o}{=} \PYG{n}{Mean}\PYG{p}{()}
            \PYG{k}{return} \PYG{n}{mean\PYGZus{}op}\PYG{o}{.}\PYG{n}{forward}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{)}

        \PYG{k}{def}\PYG{+w}{ }\PYG{n+nf}{sum}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{dim}\PYG{p}{:} \PYG{n+nb}{int} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{keepdims}\PYG{p}{:} \PYG{n+nb}{bool} \PYG{o}{=} \PYG{k+kc}{False}\PYG{p}{)} \PYG{o}{\PYGZhy{}\PYGZgt{}} \PYG{n}{Tensor}\PYG{p}{:}
\PYG{+w}{            }\PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}Computes sum of a tensor}

\PYG{l+s+sd}{            Args:}
\PYG{l+s+sd}{                axis (int, optional): axis to sum across. Defaults to \PYGZhy{}1.}
\PYG{l+s+sd}{                keepdims (bool, optional): reduce summed axis to 1?. Defaults to False.}

\PYG{l+s+sd}{            Returns:}
\PYG{l+s+sd}{                Tensor:}
\PYG{l+s+sd}{            \PYGZdq{}\PYGZdq{}\PYGZdq{}}
            \PYG{n}{sum\PYGZus{}op} \PYG{o}{=} \PYG{n}{Sum}\PYG{p}{()}
            \PYG{k}{return} \PYG{n}{sum\PYGZus{}op}\PYG{o}{.}\PYG{n}{forward}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{dim}\PYG{o}{=}\PYG{n}{dim}\PYG{p}{,} \PYG{n}{keepdims}\PYG{o}{=}\PYG{n}{keepdims}\PYG{p}{)}

        \PYG{k}{def}\PYG{+w}{ }\PYG{n+nf}{log}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{)} \PYG{o}{\PYGZhy{}\PYGZgt{}} \PYG{n}{Tensor}\PYG{p}{:}
\PYG{+w}{            }\PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}Computes element wise log of tensor}

\PYG{l+s+sd}{            Returns:}
\PYG{l+s+sd}{                Tensor: \PYGZus{}description\PYGZus{}}
\PYG{l+s+sd}{            \PYGZdq{}\PYGZdq{}\PYGZdq{}}
            \PYG{n}{log\PYGZus{}op} \PYG{o}{=} \PYG{n}{Log}\PYG{p}{()}
            \PYG{k}{return} \PYG{n}{log\PYGZus{}op}\PYG{o}{.}\PYG{n}{forward}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{)}

        \PYG{k}{def}\PYG{+w}{ }\PYG{n+nf}{exp}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{)} \PYG{o}{\PYGZhy{}\PYGZgt{}} \PYG{n}{Tensor}\PYG{p}{:}
\PYG{+w}{            }\PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}e\PYGZca{}}

\PYG{l+s+sd}{            Returns:}
\PYG{l+s+sd}{                Tensor:}
\PYG{l+s+sd}{            \PYGZdq{}\PYGZdq{}\PYGZdq{}}
            \PYG{n}{exp\PYGZus{}op} \PYG{o}{=} \PYG{n}{Exp}\PYG{p}{()}
            \PYG{k}{return} \PYG{n}{exp\PYGZus{}op}\PYG{o}{.}\PYG{n}{forward}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{)}

        \PYG{k}{def}\PYG{+w}{ }\PYG{n+nf}{convolve2d}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{k}\PYG{p}{:} \PYG{n}{Tensorable}\PYG{p}{,} \PYG{n}{b}\PYG{p}{:} \PYG{n}{Tensorable} \PYG{o}{=} \PYG{k+kc}{None}\PYG{p}{)} \PYG{o}{\PYGZhy{}\PYGZgt{}} \PYG{n}{Tensor}\PYG{p}{:}
\PYG{+w}{            }\PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}2D convolutional layer of the tensor}

\PYG{l+s+sd}{            Args:}
\PYG{l+s+sd}{                k (Tensor): kernel to use}
\PYG{l+s+sd}{                b (Tensor, optional): bias to use. Defaults to None.}

\PYG{l+s+sd}{            Returns:}
\PYG{l+s+sd}{                Tensor:}
\PYG{l+s+sd}{            \PYGZdq{}\PYGZdq{}\PYGZdq{}}
            \PYG{n}{conv\PYGZus{}op} \PYG{o}{=} \PYG{n}{Convolve2D}\PYG{p}{()}
            \PYG{k}{return} \PYG{n}{conv\PYGZus{}op}\PYG{o}{.}\PYG{n}{forward}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{k}\PYG{p}{,} \PYG{n}{b}\PYG{o}{=}\PYG{n}{b}\PYG{p}{)}

        \PYG{k}{def}\PYG{+w}{ }\PYG{n+nf}{reshape}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{shape}\PYG{p}{:} \PYG{n+nb}{tuple}\PYG{p}{[}\PYG{n+nb}{int}\PYG{p}{,} \PYG{n+nb}{int}\PYG{p}{])} \PYG{o}{\PYGZhy{}\PYGZgt{}} \PYG{n}{Tensor}\PYG{p}{:}
\PYG{+w}{            }\PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}Reshapes a tensor}

\PYG{l+s+sd}{            Args:}
\PYG{l+s+sd}{                shape (tuple[int, int]): shape to change to}

\PYG{l+s+sd}{            Returns:}
\PYG{l+s+sd}{                Tensor:}
\PYG{l+s+sd}{            \PYGZdq{}\PYGZdq{}\PYGZdq{}}
            \PYG{n}{reshape\PYGZus{}op} \PYG{o}{=} \PYG{n}{Reshape}\PYG{p}{()}
            \PYG{k}{return} \PYG{n}{reshape\PYGZus{}op}\PYG{o}{.}\PYG{n}{forward}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{shape}\PYG{o}{=}\PYG{n}{shape}\PYG{p}{)}

        \PYG{k}{def}\PYG{+w}{ }\PYG{n+nf}{pad2D}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{padding}\PYG{p}{:} \PYG{n+nb}{int}\PYG{p}{,} \PYG{n}{value}\PYG{p}{:} \PYG{n+nb}{float}\PYG{p}{)} \PYG{o}{\PYGZhy{}\PYGZgt{}} \PYG{n}{Tensor}\PYG{p}{:}
\PYG{+w}{            }\PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}Pads a 2D tensor}

\PYG{l+s+sd}{            Args:}
\PYG{l+s+sd}{                padding (int): how much to add to each edge}
\PYG{l+s+sd}{                value (float): value to pad with}

\PYG{l+s+sd}{            Returns:}
\PYG{l+s+sd}{                Tensor: padded tensor}
\PYG{l+s+sd}{            \PYGZdq{}\PYGZdq{}\PYGZdq{}}
            \PYG{n}{pad\PYGZus{}op} \PYG{o}{=} \PYG{n}{Pad2D}\PYG{p}{()}
            \PYG{k}{return} \PYG{n}{pad\PYGZus{}op}\PYG{o}{.}\PYG{n}{forward}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{padding}\PYG{o}{=}\PYG{n}{padding}\PYG{p}{,} \PYG{n}{value}\PYG{o}{=}\PYG{n}{value}\PYG{p}{)}

        \PYG{k}{def}\PYG{+w}{ }\PYG{n+nf}{relu}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{)} \PYG{o}{\PYGZhy{}\PYGZgt{}} \PYG{n}{Tensor}\PYG{p}{:}
\PYG{+w}{            }\PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}Acts as function for relu activation layer}

\PYG{l+s+sd}{            Returns:}
\PYG{l+s+sd}{                Tensor:}
\PYG{l+s+sd}{            \PYGZdq{}\PYGZdq{}\PYGZdq{}}
            \PYG{n}{relu\PYGZus{}op} \PYG{o}{=} \PYG{n}{ReLU}\PYG{p}{()}
            \PYG{k}{return} \PYG{n}{relu\PYGZus{}op}\PYG{o}{.}\PYG{n}{forward}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{)}


    \PYG{c+c1}{\PYGZsh{} ==================}
    \PYG{c+c1}{\PYGZsh{}\PYGZsh{} TENSOR FUNCTIONS}
    \PYG{c+c1}{\PYGZsh{} ==================}


    \PYG{k}{class}\PYG{+w}{ }\PYG{n+nc}{TensorFunction}\PYG{p}{(}\PYG{n}{ABC}\PYG{p}{):}
\PYG{+w}{        }\PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}Abstract class of a TensorFunction, represents the operation performed}

\PYG{l+s+sd}{        Args:}
\PYG{l+s+sd}{            ABC (\PYGZus{}type\PYGZus{}): Abstrract Class}
\PYG{l+s+sd}{        \PYGZdq{}\PYGZdq{}\PYGZdq{}}

        \PYG{n}{parents}\PYG{p}{:} \PYG{n+nb}{tuple}\PYG{p}{[}\PYG{n}{Tensor}\PYG{p}{]} \PYG{o}{=} \PYG{k+kc}{None}
        \PYG{n}{\PYGZus{}cache}\PYG{p}{:} \PYG{n+nb}{tuple}\PYG{p}{[}\PYG{n}{Tensor}\PYG{p}{]} \PYG{o}{=} \PYG{k+kc}{None}


    \PYG{k}{class}\PYG{+w}{ }\PYG{n+nc}{Addition}\PYG{p}{(}\PYG{n}{TensorFunction}\PYG{p}{):}
\PYG{+w}{        }\PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}Operation to add two tensors}

\PYG{l+s+sd}{        Args:}
\PYG{l+s+sd}{            TensorFunction (\PYGZus{}type\PYGZus{}): \PYGZus{}description\PYGZus{}}
\PYG{l+s+sd}{        \PYGZdq{}\PYGZdq{}\PYGZdq{}}

        \PYG{k}{def}\PYG{+w}{ }\PYG{n+nf}{forward}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{a}\PYG{p}{:} \PYG{n}{Tensor}\PYG{p}{,} \PYG{n}{b}\PYG{p}{:} \PYG{n}{Tensor}\PYG{p}{)} \PYG{o}{\PYGZhy{}\PYGZgt{}} \PYG{n}{Tensor}\PYG{p}{:}
\PYG{+w}{            }\PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}Computes the addition of two tensors}

\PYG{l+s+sd}{            Args:}
\PYG{l+s+sd}{                a (Tensor): one tensor to add}
\PYG{l+s+sd}{                b (Tensor): other tensor to add}

\PYG{l+s+sd}{            Returns:}
\PYG{l+s+sd}{                Tensor: tensor where data is addition of parents}
\PYG{l+s+sd}{            \PYGZdq{}\PYGZdq{}\PYGZdq{}}
            \PYG{n}{new\PYGZus{}data} \PYG{o}{=} \PYG{n}{a}\PYG{o}{.}\PYG{n}{data} \PYG{o}{+} \PYG{n}{b}\PYG{o}{.}\PYG{n}{data}

            \PYG{n}{requires\PYGZus{}grad} \PYG{o}{=} \PYG{n}{a}\PYG{o}{.}\PYG{n}{requires\PYGZus{}grad} \PYG{o+ow}{or} \PYG{n}{b}\PYG{o}{.}\PYG{n}{requires\PYGZus{}grad}

            \PYG{n}{y} \PYG{o}{=} \PYG{n}{Tensor}\PYG{p}{(}\PYG{n}{new\PYGZus{}data}\PYG{p}{,} \PYG{n}{requires\PYGZus{}grad}\PYG{o}{=}\PYG{n}{requires\PYGZus{}grad}\PYG{p}{,} \PYG{n}{operation}\PYG{o}{=}\PYG{n+nb+bp}{self}\PYG{p}{)}

            \PYG{k}{if} \PYG{n}{is\PYGZus{}grad\PYGZus{}enabled}\PYG{p}{():}
                \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{parents} \PYG{o}{=} \PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}

                \PYG{n}{a}\PYG{o}{.}\PYG{n}{children}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{y}\PYG{p}{)}
                \PYG{n}{b}\PYG{o}{.}\PYG{n}{children}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{y}\PYG{p}{)}

                \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{\PYGZus{}cache} \PYG{o}{=} \PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}

            \PYG{k}{return} \PYG{n}{y}

        \PYG{k}{def}\PYG{+w}{ }\PYG{n+nf}{backward}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{dy}\PYG{p}{:} \PYG{n}{np}\PYG{o}{.}\PYG{n}{ndarray}\PYG{p}{,} \PYG{n}{y}\PYG{p}{:} \PYG{n}{Tensor}\PYG{p}{)} \PYG{o}{\PYGZhy{}\PYGZgt{}} \PYG{k+kc}{None}\PYG{p}{:}
\PYG{+w}{            }\PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}Computes gradients for tensors stored in cache}

\PYG{l+s+sd}{            Args:}
\PYG{l+s+sd}{                dy (np.ndarray): gradient from previous backward (to be used with chain rule)}
\PYG{l+s+sd}{                y (Tensor): output tensor}
\PYG{l+s+sd}{            \PYGZdq{}\PYGZdq{}\PYGZdq{}}
            \PYG{n}{a}\PYG{p}{,} \PYG{n}{b} \PYG{o}{=} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{\PYGZus{}cache}  \PYG{c+c1}{\PYGZsh{} get tensors used to create output}

            \PYG{k}{if} \PYG{n}{a}\PYG{o}{.}\PYG{n}{requires\PYGZus{}grad}\PYG{p}{:}
                \PYG{n}{da} \PYG{o}{=} \PYG{n}{dy}  \PYG{c+c1}{\PYGZsh{} 1 * whatever the previous gradient is due to chain rule}

                \PYG{c+c1}{\PYGZsh{} now need to sum out broadcasted dimensions from numpy}
                \PYG{c+c1}{\PYGZsh{} make da the same shape as a}

                \PYG{c+c1}{\PYGZsh{} To remove broadcast dims first remove added dimensions}
                \PYG{c+c1}{\PYGZsh{} **EXAMPLE**}

                \PYG{c+c1}{\PYGZsh{} 1. Input and Gradient Shapes:}
                \PYG{c+c1}{\PYGZsh{} \PYGZhy{} Suppose a has shape (3, 1, 4).}
                \PYG{c+c1}{\PYGZsh{} \PYGZhy{} The gradient da has shape (5, 3, 1, 4) after operation and broadcasting.}

                \PYG{c+c1}{\PYGZsh{} 2. Adjustment Process:}
                \PYG{c+c1}{\PYGZsh{} in\PYGZus{}dim = len(b.shape)  \PYGZsh{} 3}
                \PYG{c+c1}{\PYGZsh{} grad\PYGZus{}dim = len(db.shape)  \PYGZsh{} 4}

                \PYG{c+c1}{\PYGZsh{} for \PYGZus{} in range(grad\PYGZus{}dim \PYGZhy{} in\PYGZus{}dim):  \PYGZsh{} 4 \PYGZhy{} 3 = 1 time}
                \PYG{c+c1}{\PYGZsh{}     db = db.sum(axis=0)}

                \PYG{c+c1}{\PYGZsh{} 3. Result:}
                \PYG{c+c1}{\PYGZsh{} \PYGZhy{} After the loop, da would have shape (3, 1, 4), matching b\PYGZsq{}s shape.}

                \PYG{n}{n\PYGZus{}dims\PYGZus{}da} \PYG{o}{=} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{dy}\PYG{o}{.}\PYG{n}{shape}\PYG{p}{)}
                \PYG{n}{n\PYGZus{}dims\PYGZus{}a} \PYG{o}{=} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{a}\PYG{o}{.}\PYG{n}{shape}\PYG{p}{)}
                \PYG{k}{for} \PYG{n}{dim} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{n\PYGZus{}dims\PYGZus{}da} \PYG{o}{\PYGZhy{}} \PYG{n}{n\PYGZus{}dims\PYGZus{}a}\PYG{p}{):}
                    \PYG{n}{da} \PYG{o}{=} \PYG{n}{da}\PYG{o}{.}\PYG{n}{sum}\PYG{p}{(}\PYG{n}{axis}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}

                \PYG{c+c1}{\PYGZsh{} Then remove singular dimensions (indicates broadcasting)}
                \PYG{c+c1}{\PYGZsh{} Summing over singular dimensions:}

                \PYG{c+c1}{\PYGZsh{} a.shape = (3, 1, 4)}

                \PYG{c+c1}{\PYGZsh{} for i, dim in enumerate(a.shape):}
                \PYG{c+c1}{\PYGZsh{}     if dim == 1:}
                \PYG{c+c1}{\PYGZsh{}         da = da.sum(axis=i, keepdims=True)}

                \PYG{c+c1}{\PYGZsh{} \PYGZhy{} This loop only executes for i=1 because dim == 1 at that position.}
                \PYG{c+c1}{\PYGZsh{} \PYGZhy{} da = da.sum(axis=1, keepdims=True)}

                \PYG{c+c1}{\PYGZsh{} Since da is already of shape (3, 1, 4), summing along `axis=1` with `keepdims=True`}
                \PYG{c+c1}{\PYGZsh{} doesn\PYGZsq{}t change its shape but ensures the gradient correctly aligns with the}
                \PYG{c+c1}{\PYGZsh{} broadcast structure.}

                \PYG{c+c1}{\PYGZsh{} This is because the keepdims is a boolean parameter.}
                \PYG{c+c1}{\PYGZsh{} If this is set to True, the axes which are reduced are}
                \PYG{c+c1}{\PYGZsh{} left in the result as dimensions with size one.}

                \PYG{c+c1}{\PYGZsh{} Therefore if da had shape (3, 2, 4) for example \PYGZhy{}}
                \PYG{c+c1}{\PYGZsh{} this loop would reduce it to (3, 1 ,4)}

                \PYG{k}{for} \PYG{n}{i}\PYG{p}{,} \PYG{n}{dim} \PYG{o+ow}{in} \PYG{n+nb}{enumerate}\PYG{p}{(}\PYG{n}{a}\PYG{o}{.}\PYG{n}{shape}\PYG{p}{):}
                    \PYG{k}{if} \PYG{n}{dim} \PYG{o}{==} \PYG{l+m+mi}{1}\PYG{p}{:}
                        \PYG{n}{da} \PYG{o}{=} \PYG{n}{da}\PYG{o}{.}\PYG{n}{sum}\PYG{p}{(}\PYG{n}{axis}\PYG{o}{=}\PYG{n}{i}\PYG{p}{,} \PYG{n}{keepdims}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{)}
                \PYG{n}{a}\PYG{o}{.}\PYG{n}{backward}\PYG{p}{(}\PYG{n}{da}\PYG{p}{,} \PYG{n}{y}\PYG{p}{)}

            \PYG{k}{if} \PYG{n}{b}\PYG{o}{.}\PYG{n}{requires\PYGZus{}grad}\PYG{p}{:}
                \PYG{n}{db} \PYG{o}{=} \PYG{n}{dy}

                \PYG{c+c1}{\PYGZsh{} Rescale gradient to have the same shape as \PYGZdq{}b\PYGZdq{}:}
                \PYG{n}{n\PYGZus{}dims\PYGZus{}db} \PYG{o}{=} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{db}\PYG{o}{.}\PYG{n}{shape}\PYG{p}{)}
                \PYG{n}{n\PYGZus{}dims\PYGZus{}b} \PYG{o}{=} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{b}\PYG{o}{.}\PYG{n}{shape}\PYG{p}{)}
                \PYG{k}{for} \PYG{n}{dim} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{n\PYGZus{}dims\PYGZus{}db} \PYG{o}{\PYGZhy{}} \PYG{n}{n\PYGZus{}dims\PYGZus{}b}\PYG{p}{):}
                    \PYG{n}{db} \PYG{o}{=} \PYG{n}{db}\PYG{o}{.}\PYG{n}{sum}\PYG{p}{(}\PYG{n}{axis}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}

                \PYG{k}{for} \PYG{n}{i}\PYG{p}{,} \PYG{n}{dim} \PYG{o+ow}{in} \PYG{n+nb}{enumerate}\PYG{p}{(}\PYG{n}{b}\PYG{o}{.}\PYG{n}{shape}\PYG{p}{):}
                    \PYG{k}{if} \PYG{n}{dim} \PYG{o}{==} \PYG{l+m+mi}{1}\PYG{p}{:}
                        \PYG{n}{db} \PYG{o}{=} \PYG{n}{db}\PYG{o}{.}\PYG{n}{sum}\PYG{p}{(}\PYG{n}{axis}\PYG{o}{=}\PYG{n}{i}\PYG{p}{,} \PYG{n}{keepdims}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{)}
                \PYG{n}{b}\PYG{o}{.}\PYG{n}{backward}\PYG{p}{(}\PYG{n}{db}\PYG{p}{,} \PYG{n}{y}\PYG{p}{)}


    \PYG{k}{class}\PYG{+w}{ }\PYG{n+nc}{Negation}\PYG{p}{(}\PYG{n}{TensorFunction}\PYG{p}{):}
\PYG{+w}{        }\PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}Operation to negate a tensor}

\PYG{l+s+sd}{        Args:}
\PYG{l+s+sd}{            TensorFunction (\PYGZus{}type\PYGZus{}): \PYGZus{}description\PYGZus{}}
\PYG{l+s+sd}{        \PYGZdq{}\PYGZdq{}\PYGZdq{}}

        \PYG{k}{def}\PYG{+w}{ }\PYG{n+nf}{forward}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{a}\PYG{p}{:} \PYG{n}{Tensor}\PYG{p}{)} \PYG{o}{\PYGZhy{}\PYGZgt{}} \PYG{n}{Tensor}\PYG{p}{:}
\PYG{+w}{            }\PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}Computes the negation of a tensor}

\PYG{l+s+sd}{            Args:}
\PYG{l+s+sd}{                a (Tensor): tensor to be negated}

\PYG{l+s+sd}{            Returns:}
\PYG{l+s+sd}{                Tensor: negated tensor}
\PYG{l+s+sd}{            \PYGZdq{}\PYGZdq{}\PYGZdq{}}
            \PYG{n}{new\PYGZus{}data} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{n}{a}\PYG{o}{.}\PYG{n}{data}

            \PYG{n}{y} \PYG{o}{=} \PYG{n}{Tensor}\PYG{p}{(}\PYG{n}{new\PYGZus{}data}\PYG{p}{,} \PYG{n}{requires\PYGZus{}grad}\PYG{o}{=}\PYG{n}{a}\PYG{o}{.}\PYG{n}{requires\PYGZus{}grad}\PYG{p}{,} \PYG{n}{operation}\PYG{o}{=}\PYG{n+nb+bp}{self}\PYG{p}{)}

            \PYG{k}{if} \PYG{n}{is\PYGZus{}grad\PYGZus{}enabled}\PYG{p}{():}
                \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{parents} \PYG{o}{=} \PYG{p}{(}\PYG{n}{a}\PYG{p}{,)}
                \PYG{n}{a}\PYG{o}{.}\PYG{n}{children}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{y}\PYG{p}{)}

                \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{\PYGZus{}cache} \PYG{o}{=} \PYG{p}{(}\PYG{n}{a}\PYG{p}{,)}

            \PYG{k}{return} \PYG{n}{y}

        \PYG{k}{def}\PYG{+w}{ }\PYG{n+nf}{backward}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{dy}\PYG{p}{:} \PYG{n}{np}\PYG{o}{.}\PYG{n}{ndarray}\PYG{p}{,} \PYG{n}{y}\PYG{p}{:} \PYG{n}{Tensor}\PYG{p}{)} \PYG{o}{\PYGZhy{}\PYGZgt{}} \PYG{k+kc}{None}\PYG{p}{:}
\PYG{+w}{            }\PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}Computes the gradient for tensors in cache}

\PYG{l+s+sd}{            Args:}
\PYG{l+s+sd}{                dy (np.ndarray): gradient from upstream}
\PYG{l+s+sd}{                y (Tensor): output tensor}
\PYG{l+s+sd}{            \PYGZdq{}\PYGZdq{}\PYGZdq{}}
            \PYG{p}{(}\PYG{n}{a}\PYG{p}{,)} \PYG{o}{=} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{\PYGZus{}cache}

            \PYG{k}{if} \PYG{n}{a}\PYG{o}{.}\PYG{n}{requires\PYGZus{}grad}\PYG{p}{:}
                \PYG{n}{da} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{n}{dy}
                \PYG{n}{a}\PYG{o}{.}\PYG{n}{backward}\PYG{p}{(}\PYG{n}{da}\PYG{p}{,} \PYG{n}{y}\PYG{p}{)}


    \PYG{k}{class}\PYG{+w}{ }\PYG{n+nc}{Multiplication}\PYG{p}{(}\PYG{n}{TensorFunction}\PYG{p}{):}
\PYG{+w}{        }\PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}Operation to multiply two tensors}

\PYG{l+s+sd}{        Args:}
\PYG{l+s+sd}{            TensorFunction (\PYGZus{}type\PYGZus{}): \PYGZus{}description\PYGZus{}}
\PYG{l+s+sd}{        \PYGZdq{}\PYGZdq{}\PYGZdq{}}

        \PYG{k}{def}\PYG{+w}{ }\PYG{n+nf}{forward}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{a}\PYG{p}{:} \PYG{n}{Tensor}\PYG{p}{,} \PYG{n}{b}\PYG{p}{:} \PYG{n}{Tensor}\PYG{p}{)} \PYG{o}{\PYGZhy{}\PYGZgt{}} \PYG{n}{Tensor}\PYG{p}{:}
\PYG{+w}{            }\PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}Computes the multiplication of two tensors}

\PYG{l+s+sd}{            Args:}
\PYG{l+s+sd}{                a (Tensor):}
\PYG{l+s+sd}{                b (Tensor):}

\PYG{l+s+sd}{            Returns:}
\PYG{l+s+sd}{                Tensor: product of a and b}
\PYG{l+s+sd}{            \PYGZdq{}\PYGZdq{}\PYGZdq{}}
            \PYG{n}{new\PYGZus{}data} \PYG{o}{=} \PYG{n}{a}\PYG{o}{.}\PYG{n}{data} \PYG{o}{*} \PYG{n}{b}\PYG{o}{.}\PYG{n}{data}

            \PYG{n}{requires\PYGZus{}grad} \PYG{o}{=} \PYG{n}{a}\PYG{o}{.}\PYG{n}{requires\PYGZus{}grad} \PYG{o+ow}{or} \PYG{n}{b}\PYG{o}{.}\PYG{n}{requires\PYGZus{}grad}

            \PYG{n}{y} \PYG{o}{=} \PYG{n}{Tensor}\PYG{p}{(}\PYG{n}{new\PYGZus{}data}\PYG{p}{,} \PYG{n}{requires\PYGZus{}grad}\PYG{o}{=}\PYG{n}{requires\PYGZus{}grad}\PYG{p}{,} \PYG{n}{operation}\PYG{o}{=}\PYG{n+nb+bp}{self}\PYG{p}{)}

            \PYG{k}{if} \PYG{n}{is\PYGZus{}grad\PYGZus{}enabled}\PYG{p}{():}
                \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{\PYGZus{}cache} \PYG{o}{=} \PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}

                \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{parents} \PYG{o}{=} \PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}
                \PYG{n}{a}\PYG{o}{.}\PYG{n}{children}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{y}\PYG{p}{)}
                \PYG{n}{b}\PYG{o}{.}\PYG{n}{children}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{y}\PYG{p}{)}

            \PYG{k}{return} \PYG{n}{y}

        \PYG{k}{def}\PYG{+w}{ }\PYG{n+nf}{backward}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{dy}\PYG{p}{:} \PYG{n}{np}\PYG{o}{.}\PYG{n}{ndarray}\PYG{p}{,} \PYG{n}{y}\PYG{p}{:} \PYG{n}{Tensor}\PYG{p}{)} \PYG{o}{\PYGZhy{}\PYGZgt{}} \PYG{k+kc}{None}\PYG{p}{:}
\PYG{+w}{            }\PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}Computes gradients for cached tensors}

\PYG{l+s+sd}{            Args:}
\PYG{l+s+sd}{                dy (Tensor): output grad}
\PYG{l+s+sd}{                y (Tensor):}
\PYG{l+s+sd}{            \PYGZdq{}\PYGZdq{}\PYGZdq{}}

            \PYG{n}{a}\PYG{p}{,} \PYG{n}{b} \PYG{o}{=} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{\PYGZus{}cache}

            \PYG{k}{if} \PYG{n}{a}\PYG{o}{.}\PYG{n}{requires\PYGZus{}grad}\PYG{p}{:}
                \PYG{n}{da} \PYG{o}{=} \PYG{n}{dy} \PYG{o}{*} \PYG{n}{b}\PYG{o}{.}\PYG{n}{data}

                \PYG{n}{n\PYGZus{}dims\PYGZus{}da} \PYG{o}{=} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{dy}\PYG{o}{.}\PYG{n}{shape}\PYG{p}{)}
                \PYG{n}{n\PYGZus{}dims\PYGZus{}a} \PYG{o}{=} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{a}\PYG{o}{.}\PYG{n}{shape}\PYG{p}{)}
                \PYG{k}{for} \PYG{n}{dim} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{n\PYGZus{}dims\PYGZus{}da} \PYG{o}{\PYGZhy{}} \PYG{n}{n\PYGZus{}dims\PYGZus{}a}\PYG{p}{):}
                    \PYG{n}{da} \PYG{o}{=} \PYG{n}{da}\PYG{o}{.}\PYG{n}{sum}\PYG{p}{(}\PYG{n}{axis}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}
                \PYG{k}{for} \PYG{n}{i}\PYG{p}{,} \PYG{n}{dim} \PYG{o+ow}{in} \PYG{n+nb}{enumerate}\PYG{p}{(}\PYG{n}{a}\PYG{o}{.}\PYG{n}{shape}\PYG{p}{):}
                    \PYG{k}{if} \PYG{n}{dim} \PYG{o}{==} \PYG{l+m+mi}{1}\PYG{p}{:}
                        \PYG{n}{da} \PYG{o}{=} \PYG{n}{da}\PYG{o}{.}\PYG{n}{sum}\PYG{p}{(}\PYG{n}{axis}\PYG{o}{=}\PYG{n}{i}\PYG{p}{,} \PYG{n}{keepdims}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{)}

                \PYG{n}{a}\PYG{o}{.}\PYG{n}{backward}\PYG{p}{(}\PYG{n}{da}\PYG{p}{,} \PYG{n}{y}\PYG{p}{)}

            \PYG{k}{if} \PYG{n}{b}\PYG{o}{.}\PYG{n}{requires\PYGZus{}grad}\PYG{p}{:}
                \PYG{n}{db} \PYG{o}{=} \PYG{n}{dy} \PYG{o}{*} \PYG{n}{a}\PYG{o}{.}\PYG{n}{data}

                \PYG{n}{n\PYGZus{}dims\PYGZus{}db} \PYG{o}{=} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{dy}\PYG{o}{.}\PYG{n}{shape}\PYG{p}{)}
                \PYG{n}{n\PYGZus{}dims\PYGZus{}b} \PYG{o}{=} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{b}\PYG{o}{.}\PYG{n}{shape}\PYG{p}{)}
                \PYG{k}{for} \PYG{n}{dim} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{n\PYGZus{}dims\PYGZus{}db} \PYG{o}{\PYGZhy{}} \PYG{n}{n\PYGZus{}dims\PYGZus{}b}\PYG{p}{):}
                    \PYG{n}{db} \PYG{o}{=} \PYG{n}{db}\PYG{o}{.}\PYG{n}{sum}\PYG{p}{(}\PYG{n}{axis}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}
                \PYG{k}{for} \PYG{n}{i}\PYG{p}{,} \PYG{n}{dim} \PYG{o+ow}{in} \PYG{n+nb}{enumerate}\PYG{p}{(}\PYG{n}{b}\PYG{o}{.}\PYG{n}{shape}\PYG{p}{):}
                    \PYG{k}{if} \PYG{n}{dim} \PYG{o}{==} \PYG{l+m+mi}{1}\PYG{p}{:}
                        \PYG{n}{db} \PYG{o}{=} \PYG{n}{db}\PYG{o}{.}\PYG{n}{sum}\PYG{p}{(}\PYG{n}{axis}\PYG{o}{=}\PYG{n}{i}\PYG{p}{,} \PYG{n}{keepdims}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{)}

                \PYG{n}{b}\PYG{o}{.}\PYG{n}{backward}\PYG{p}{(}\PYG{n}{db}\PYG{p}{,} \PYG{n}{y}\PYG{p}{)}


    \PYG{k}{class}\PYG{+w}{ }\PYG{n+nc}{Division}\PYG{p}{(}\PYG{n}{TensorFunction}\PYG{p}{):}
\PYG{+w}{        }\PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}Division operation}

\PYG{l+s+sd}{        Args:}
\PYG{l+s+sd}{            TensorFunction (\PYGZus{}type\PYGZus{}): \PYGZus{}description\PYGZus{}}
\PYG{l+s+sd}{        \PYGZdq{}\PYGZdq{}\PYGZdq{}}

        \PYG{k}{def}\PYG{+w}{ }\PYG{n+nf}{forward}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{a}\PYG{p}{:} \PYG{n}{Tensor}\PYG{p}{,} \PYG{n}{b}\PYG{p}{:} \PYG{n}{Tensor}\PYG{p}{)} \PYG{o}{\PYGZhy{}\PYGZgt{}} \PYG{n}{Tensor}\PYG{p}{:}
\PYG{+w}{            }\PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}Computes the division of two tensors}

\PYG{l+s+sd}{            Args:}
\PYG{l+s+sd}{                a (Tensor):}
\PYG{l+s+sd}{                b (Tensor):}

\PYG{l+s+sd}{            Returns:}
\PYG{l+s+sd}{                Tensor: tensor a / tensor b}
\PYG{l+s+sd}{            \PYGZdq{}\PYGZdq{}\PYGZdq{}}
            \PYG{n}{new\PYGZus{}data} \PYG{o}{=} \PYG{n}{a}\PYG{o}{.}\PYG{n}{data} \PYG{o}{/} \PYG{n}{b}\PYG{o}{.}\PYG{n}{data}

            \PYG{n}{requires\PYGZus{}grad} \PYG{o}{=} \PYG{n}{a}\PYG{o}{.}\PYG{n}{requires\PYGZus{}grad} \PYG{o+ow}{or} \PYG{n}{b}\PYG{o}{.}\PYG{n}{requires\PYGZus{}grad}

            \PYG{n}{y} \PYG{o}{=} \PYG{n}{Tensor}\PYG{p}{(}\PYG{n}{new\PYGZus{}data}\PYG{p}{,} \PYG{n}{requires\PYGZus{}grad}\PYG{o}{=}\PYG{n}{requires\PYGZus{}grad}\PYG{p}{,} \PYG{n}{operation}\PYG{o}{=}\PYG{n+nb+bp}{self}\PYG{p}{)}

            \PYG{k}{if} \PYG{n}{is\PYGZus{}grad\PYGZus{}enabled}\PYG{p}{():}
                \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{parents} \PYG{o}{=} \PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}
                \PYG{n}{a}\PYG{o}{.}\PYG{n}{children}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{y}\PYG{p}{)}
                \PYG{n}{b}\PYG{o}{.}\PYG{n}{children}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{y}\PYG{p}{)}

                \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{\PYGZus{}cache} \PYG{o}{=} \PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}

            \PYG{k}{return} \PYG{n}{y}

        \PYG{k}{def}\PYG{+w}{ }\PYG{n+nf}{backward}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{dy}\PYG{p}{:} \PYG{n}{np}\PYG{o}{.}\PYG{n}{ndarray}\PYG{p}{,} \PYG{n}{y}\PYG{p}{:} \PYG{n}{Tensor}\PYG{p}{):}
\PYG{+w}{            }\PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}Computes gradients of cached tensors}

\PYG{l+s+sd}{            Args:}
\PYG{l+s+sd}{                dy (Tensor):}
\PYG{l+s+sd}{                y (Tensor):}
\PYG{l+s+sd}{            \PYGZdq{}\PYGZdq{}\PYGZdq{}}
            \PYG{n}{a}\PYG{p}{,} \PYG{n}{b} \PYG{o}{=} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{\PYGZus{}cache}

            \PYG{k}{if} \PYG{n}{a}\PYG{o}{.}\PYG{n}{requires\PYGZus{}grad}\PYG{p}{:}
                \PYG{n}{da} \PYG{o}{=} \PYG{n}{dy} \PYG{o}{*} \PYG{p}{(}\PYG{l+m+mi}{1} \PYG{o}{/} \PYG{n}{b}\PYG{o}{.}\PYG{n}{data}\PYG{p}{)}

                \PYG{n}{n\PYGZus{}dims\PYGZus{}da} \PYG{o}{=} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{dy}\PYG{o}{.}\PYG{n}{shape}\PYG{p}{)}
                \PYG{n}{n\PYGZus{}dims\PYGZus{}a} \PYG{o}{=} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{a}\PYG{o}{.}\PYG{n}{shape}\PYG{p}{)}
                \PYG{k}{for} \PYG{n}{dim} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{n\PYGZus{}dims\PYGZus{}da} \PYG{o}{\PYGZhy{}} \PYG{n}{n\PYGZus{}dims\PYGZus{}a}\PYG{p}{):}
                    \PYG{n}{da} \PYG{o}{=} \PYG{n}{da}\PYG{o}{.}\PYG{n}{sum}\PYG{p}{(}\PYG{n}{axis}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}
                \PYG{k}{for} \PYG{n}{i}\PYG{p}{,} \PYG{n}{dim} \PYG{o+ow}{in} \PYG{n+nb}{enumerate}\PYG{p}{(}\PYG{n}{a}\PYG{o}{.}\PYG{n}{shape}\PYG{p}{):}
                    \PYG{k}{if} \PYG{n}{dim} \PYG{o}{==} \PYG{l+m+mi}{1}\PYG{p}{:}
                        \PYG{n}{da} \PYG{o}{=} \PYG{n}{da}\PYG{o}{.}\PYG{n}{sum}\PYG{p}{(}\PYG{n}{axis}\PYG{o}{=}\PYG{n}{i}\PYG{p}{,} \PYG{n}{keepdims}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{)}

                \PYG{n}{a}\PYG{o}{.}\PYG{n}{backward}\PYG{p}{(}\PYG{n}{da}\PYG{p}{,} \PYG{n}{y}\PYG{p}{)}

            \PYG{k}{if} \PYG{n}{b}\PYG{o}{.}\PYG{n}{requires\PYGZus{}grad}\PYG{p}{:}
                \PYG{n}{db} \PYG{o}{=} \PYG{n}{dy} \PYG{o}{*} \PYG{o}{\PYGZhy{}}\PYG{p}{(}\PYG{n}{a}\PYG{o}{.}\PYG{n}{data} \PYG{o}{/} \PYG{p}{(}\PYG{n}{b}\PYG{o}{.}\PYG{n}{data}\PYG{o}{**}\PYG{l+m+mi}{2}\PYG{p}{))}

                \PYG{n}{n\PYGZus{}dims\PYGZus{}db} \PYG{o}{=} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{dy}\PYG{o}{.}\PYG{n}{shape}\PYG{p}{)}
                \PYG{n}{n\PYGZus{}dims\PYGZus{}b} \PYG{o}{=} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{b}\PYG{o}{.}\PYG{n}{shape}\PYG{p}{)}
                \PYG{k}{for} \PYG{n}{dim} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{n\PYGZus{}dims\PYGZus{}db} \PYG{o}{\PYGZhy{}} \PYG{n}{n\PYGZus{}dims\PYGZus{}b}\PYG{p}{):}
                    \PYG{n}{db} \PYG{o}{=} \PYG{n}{db}\PYG{o}{.}\PYG{n}{sum}\PYG{p}{(}\PYG{n}{axis}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}
                \PYG{k}{for} \PYG{n}{i}\PYG{p}{,} \PYG{n}{dim} \PYG{o+ow}{in} \PYG{n+nb}{enumerate}\PYG{p}{(}\PYG{n}{b}\PYG{o}{.}\PYG{n}{shape}\PYG{p}{):}
                    \PYG{k}{if} \PYG{n}{dim} \PYG{o}{==} \PYG{l+m+mi}{1}\PYG{p}{:}
                        \PYG{n}{db} \PYG{o}{=} \PYG{n}{db}\PYG{o}{.}\PYG{n}{sum}\PYG{p}{(}\PYG{n}{axis}\PYG{o}{=}\PYG{n}{i}\PYG{p}{,} \PYG{n}{keepdims}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{)}

                \PYG{n}{b}\PYG{o}{.}\PYG{n}{backward}\PYG{p}{(}\PYG{n}{db}\PYG{p}{,} \PYG{n}{y}\PYG{p}{)}


    \PYG{k}{class}\PYG{+w}{ }\PYG{n+nc}{MatrixMultiplication}\PYG{p}{(}\PYG{n}{TensorFunction}\PYG{p}{):}
\PYG{+w}{        }\PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}Matrix Multiplication operation}

\PYG{l+s+sd}{        Args:}
\PYG{l+s+sd}{            TensorFunction (\PYGZus{}type\PYGZus{}):}
\PYG{l+s+sd}{        \PYGZdq{}\PYGZdq{}\PYGZdq{}}

        \PYG{k}{def}\PYG{+w}{ }\PYG{n+nf}{forward}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{a}\PYG{p}{:} \PYG{n}{Tensor}\PYG{p}{,} \PYG{n}{b}\PYG{p}{:} \PYG{n}{Tensor}\PYG{p}{)} \PYG{o}{\PYGZhy{}\PYGZgt{}} \PYG{n}{Tensor}\PYG{p}{:}
\PYG{+w}{            }\PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}Computes the matrix multiplication of two tensors}

\PYG{l+s+sd}{            Args:}
\PYG{l+s+sd}{                a (Tensor):}
\PYG{l+s+sd}{                b (Tensor):}

\PYG{l+s+sd}{            Returns:}
\PYG{l+s+sd}{                Tensor: Tensor of a @ b}
\PYG{l+s+sd}{            \PYGZdq{}\PYGZdq{}\PYGZdq{}}
            \PYG{n}{new\PYGZus{}data} \PYG{o}{=} \PYG{n}{a}\PYG{o}{.}\PYG{n}{data} \PYG{o}{@} \PYG{n}{b}\PYG{o}{.}\PYG{n}{data}

            \PYG{n}{requires\PYGZus{}grad} \PYG{o}{=} \PYG{n}{a}\PYG{o}{.}\PYG{n}{requires\PYGZus{}grad} \PYG{o+ow}{or} \PYG{n}{b}\PYG{o}{.}\PYG{n}{requires\PYGZus{}grad}

            \PYG{n}{y} \PYG{o}{=} \PYG{n}{Tensor}\PYG{p}{(}\PYG{n}{new\PYGZus{}data}\PYG{p}{,} \PYG{n}{requires\PYGZus{}grad}\PYG{o}{=}\PYG{n}{requires\PYGZus{}grad}\PYG{p}{,} \PYG{n}{operation}\PYG{o}{=}\PYG{n+nb+bp}{self}\PYG{p}{)}

            \PYG{k}{if} \PYG{n}{is\PYGZus{}grad\PYGZus{}enabled}\PYG{p}{():}
                \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{parents} \PYG{o}{=} \PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}

                \PYG{n}{a}\PYG{o}{.}\PYG{n}{children}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{y}\PYG{p}{)}
                \PYG{n}{b}\PYG{o}{.}\PYG{n}{children}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{y}\PYG{p}{)}

                \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{\PYGZus{}cache} \PYG{o}{=} \PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}

            \PYG{k}{return} \PYG{n}{y}

        \PYG{k}{def}\PYG{+w}{ }\PYG{n+nf}{backward}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{dy}\PYG{p}{:} \PYG{n}{np}\PYG{o}{.}\PYG{n}{ndarray}\PYG{p}{,} \PYG{n}{y}\PYG{p}{:} \PYG{n}{Tensor}\PYG{p}{)} \PYG{o}{\PYGZhy{}\PYGZgt{}} \PYG{k+kc}{None}\PYG{p}{:}
\PYG{+w}{            }\PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}Computes gradients for cached tensors}

\PYG{l+s+sd}{            Args:}
\PYG{l+s+sd}{                dy (Tensor):}
\PYG{l+s+sd}{                y (Tensor):}
\PYG{l+s+sd}{            \PYGZdq{}\PYGZdq{}\PYGZdq{}}
            \PYG{n}{a}\PYG{p}{,} \PYG{n}{b} \PYG{o}{=} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{\PYGZus{}cache}

            \PYG{k}{if} \PYG{n}{a}\PYG{o}{.}\PYG{n}{requires\PYGZus{}grad}\PYG{p}{:}
                \PYG{n}{da} \PYG{o}{=} \PYG{n}{dy} \PYG{o}{@} \PYG{n}{b}\PYG{o}{.}\PYG{n}{data}\PYG{o}{.}\PYG{n}{swapaxes}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{p}{)}

                \PYG{n}{n\PYGZus{}dims\PYGZus{}da} \PYG{o}{=} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{dy}\PYG{o}{.}\PYG{n}{shape}\PYG{p}{)}
                \PYG{n}{n\PYGZus{}dims\PYGZus{}a} \PYG{o}{=} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{a}\PYG{o}{.}\PYG{n}{shape}\PYG{p}{)}
                \PYG{k}{for} \PYG{n}{\PYGZus{}} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{n\PYGZus{}dims\PYGZus{}da} \PYG{o}{\PYGZhy{}} \PYG{n}{n\PYGZus{}dims\PYGZus{}a}\PYG{p}{):}
                    \PYG{n}{da} \PYG{o}{=} \PYG{n}{da}\PYG{o}{.}\PYG{n}{sum}\PYG{p}{(}\PYG{n}{axis}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}

                \PYG{n}{a}\PYG{o}{.}\PYG{n}{backward}\PYG{p}{(}\PYG{n}{da}\PYG{p}{,} \PYG{n}{y}\PYG{p}{)}

            \PYG{k}{if} \PYG{n}{b}\PYG{o}{.}\PYG{n}{requires\PYGZus{}grad}\PYG{p}{:}
                \PYG{n}{db} \PYG{o}{=} \PYG{n}{a}\PYG{o}{.}\PYG{n}{data}\PYG{o}{.}\PYG{n}{swapaxes}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{p}{)} \PYG{o}{@} \PYG{n}{dy}

                \PYG{n}{n\PYGZus{}dims\PYGZus{}db} \PYG{o}{=} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{dy}\PYG{o}{.}\PYG{n}{shape}\PYG{p}{)}
                \PYG{n}{n\PYGZus{}dims\PYGZus{}b} \PYG{o}{=} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{b}\PYG{o}{.}\PYG{n}{shape}\PYG{p}{)}
                \PYG{k}{for} \PYG{n}{\PYGZus{}} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{n\PYGZus{}dims\PYGZus{}db} \PYG{o}{\PYGZhy{}} \PYG{n}{n\PYGZus{}dims\PYGZus{}b}\PYG{p}{):}
                    \PYG{n}{db} \PYG{o}{=} \PYG{n}{db}\PYG{o}{.}\PYG{n}{sum}\PYG{p}{(}\PYG{n}{axis}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}

                \PYG{n}{b}\PYG{o}{.}\PYG{n}{backward}\PYG{p}{(}\PYG{n}{db}\PYG{p}{,} \PYG{n}{y}\PYG{p}{)}


    \PYG{k}{class}\PYG{+w}{ }\PYG{n+nc}{Power}\PYG{p}{(}\PYG{n}{TensorFunction}\PYG{p}{):}
\PYG{+w}{        }\PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}Power function e.g. a\PYGZca{}b}

\PYG{l+s+sd}{        Args:}
\PYG{l+s+sd}{            TensorFunction (\PYGZus{}type\PYGZus{}): \PYGZus{}description\PYGZus{}}
\PYG{l+s+sd}{        \PYGZdq{}\PYGZdq{}\PYGZdq{}}

        \PYG{k}{def}\PYG{+w}{ }\PYG{n+nf}{forward}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{a}\PYG{p}{:} \PYG{n}{Tensor}\PYG{p}{,} \PYG{n}{b}\PYG{p}{:} \PYG{n}{Tensor}\PYG{p}{)} \PYG{o}{\PYGZhy{}\PYGZgt{}} \PYG{n}{Tensor}\PYG{p}{:}
\PYG{+w}{            }\PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}Computes one tensor to the power of another}

\PYG{l+s+sd}{            Args:}
\PYG{l+s+sd}{                a (Tensor):}
\PYG{l+s+sd}{                b (Tensor):}

\PYG{l+s+sd}{            Returns:}
\PYG{l+s+sd}{                Tensor: Tensor with a\PYGZca{}b}
\PYG{l+s+sd}{            \PYGZdq{}\PYGZdq{}\PYGZdq{}}
            \PYG{n}{new\PYGZus{}data} \PYG{o}{=} \PYG{n}{a}\PYG{o}{.}\PYG{n}{data}\PYG{o}{**}\PYG{n}{b}\PYG{o}{.}\PYG{n}{data}

            \PYG{n}{requires\PYGZus{}grad} \PYG{o}{=} \PYG{n}{a}\PYG{o}{.}\PYG{n}{requires\PYGZus{}grad} \PYG{o+ow}{or} \PYG{n}{b}\PYG{o}{.}\PYG{n}{requires\PYGZus{}grad}

            \PYG{n}{y} \PYG{o}{=} \PYG{n}{Tensor}\PYG{p}{(}\PYG{n}{new\PYGZus{}data}\PYG{p}{,} \PYG{n}{requires\PYGZus{}grad}\PYG{o}{=}\PYG{n}{requires\PYGZus{}grad}\PYG{p}{,} \PYG{n}{operation}\PYG{o}{=}\PYG{n+nb+bp}{self}\PYG{p}{)}

            \PYG{k}{if} \PYG{n}{is\PYGZus{}grad\PYGZus{}enabled}\PYG{p}{():}
                \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{parents} \PYG{o}{=} \PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}
                \PYG{n}{a}\PYG{o}{.}\PYG{n}{children}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{y}\PYG{p}{)}
                \PYG{n}{b}\PYG{o}{.}\PYG{n}{children}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{y}\PYG{p}{)}

                \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{\PYGZus{}cache} \PYG{o}{=} \PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}

            \PYG{k}{return} \PYG{n}{y}

        \PYG{k}{def}\PYG{+w}{ }\PYG{n+nf}{backward}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{dy}\PYG{p}{:} \PYG{n}{np}\PYG{o}{.}\PYG{n}{ndarray}\PYG{p}{,} \PYG{n}{y}\PYG{p}{:} \PYG{n}{Tensor}\PYG{p}{)} \PYG{o}{\PYGZhy{}\PYGZgt{}} \PYG{k+kc}{None}\PYG{p}{:}
\PYG{+w}{            }\PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}Computes gradients of cached tensors}

\PYG{l+s+sd}{            Args:}
\PYG{l+s+sd}{                dy (Tensor): \PYGZus{}description\PYGZus{}}
\PYG{l+s+sd}{                y (Tensor): \PYGZus{}description\PYGZus{}}
\PYG{l+s+sd}{            \PYGZdq{}\PYGZdq{}\PYGZdq{}}
            \PYG{n}{a}\PYG{p}{,} \PYG{n}{b} \PYG{o}{=} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{\PYGZus{}cache}

            \PYG{k}{if} \PYG{n}{a}\PYG{o}{.}\PYG{n}{requires\PYGZus{}grad}\PYG{p}{:}
                \PYG{n}{da} \PYG{o}{=} \PYG{n}{dy} \PYG{o}{*} \PYG{p}{(}\PYG{n}{b}\PYG{o}{.}\PYG{n}{data} \PYG{o}{*} \PYG{p}{(}\PYG{n}{a}\PYG{o}{.}\PYG{n}{data} \PYG{o}{**} \PYG{p}{(}\PYG{n}{b}\PYG{o}{.}\PYG{n}{data} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{1}\PYG{p}{)))}

                \PYG{n}{n\PYGZus{}dims\PYGZus{}da} \PYG{o}{=} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{dy}\PYG{o}{.}\PYG{n}{shape}\PYG{p}{)}
                \PYG{n}{n\PYGZus{}dims\PYGZus{}a} \PYG{o}{=} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{a}\PYG{o}{.}\PYG{n}{shape}\PYG{p}{)}
                \PYG{k}{for} \PYG{n}{dim} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{n\PYGZus{}dims\PYGZus{}da} \PYG{o}{\PYGZhy{}} \PYG{n}{n\PYGZus{}dims\PYGZus{}a}\PYG{p}{):}
                    \PYG{n}{da} \PYG{o}{=} \PYG{n}{da}\PYG{o}{.}\PYG{n}{sum}\PYG{p}{(}\PYG{n}{axis}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}
                \PYG{k}{for} \PYG{n}{i}\PYG{p}{,} \PYG{n}{dim} \PYG{o+ow}{in} \PYG{n+nb}{enumerate}\PYG{p}{(}\PYG{n}{a}\PYG{o}{.}\PYG{n}{shape}\PYG{p}{):}
                    \PYG{k}{if} \PYG{n}{dim} \PYG{o}{==} \PYG{l+m+mi}{1}\PYG{p}{:}
                        \PYG{n}{da} \PYG{o}{=} \PYG{n}{da}\PYG{o}{.}\PYG{n}{sum}\PYG{p}{(}\PYG{n}{axis}\PYG{o}{=}\PYG{n}{i}\PYG{p}{,} \PYG{n}{keepdims}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{)}

                \PYG{n}{a}\PYG{o}{.}\PYG{n}{backward}\PYG{p}{(}\PYG{n}{da}\PYG{p}{,} \PYG{n}{y}\PYG{p}{)}

            \PYG{k}{if} \PYG{n}{b}\PYG{o}{.}\PYG{n}{requires\PYGZus{}grad}\PYG{p}{:}
                \PYG{n}{db} \PYG{o}{=} \PYG{n}{dy} \PYG{o}{*} \PYG{p}{((}\PYG{n}{a}\PYG{o}{.}\PYG{n}{data}\PYG{o}{**}\PYG{n}{b}\PYG{o}{.}\PYG{n}{data}\PYG{p}{)} \PYG{o}{*} \PYG{n}{np}\PYG{o}{.}\PYG{n}{log}\PYG{p}{(}\PYG{n}{a}\PYG{o}{.}\PYG{n}{data}\PYG{p}{))}

                \PYG{n}{n\PYGZus{}dims\PYGZus{}db} \PYG{o}{=} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{dy}\PYG{o}{.}\PYG{n}{shape}\PYG{p}{)}
                \PYG{n}{n\PYGZus{}dims\PYGZus{}b} \PYG{o}{=} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{b}\PYG{o}{.}\PYG{n}{shape}\PYG{p}{)}
                \PYG{k}{for} \PYG{n}{dim} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{n\PYGZus{}dims\PYGZus{}db} \PYG{o}{\PYGZhy{}} \PYG{n}{n\PYGZus{}dims\PYGZus{}b}\PYG{p}{):}
                    \PYG{n}{db} \PYG{o}{=} \PYG{n}{db}\PYG{o}{.}\PYG{n}{sum}\PYG{p}{(}\PYG{n}{axis}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}
                \PYG{k}{for} \PYG{n}{i}\PYG{p}{,} \PYG{n}{dim} \PYG{o+ow}{in} \PYG{n+nb}{enumerate}\PYG{p}{(}\PYG{n}{b}\PYG{o}{.}\PYG{n}{shape}\PYG{p}{):}
                    \PYG{k}{if} \PYG{n}{dim} \PYG{o}{==} \PYG{l+m+mi}{1}\PYG{p}{:}
                        \PYG{n}{db} \PYG{o}{=} \PYG{n}{db}\PYG{o}{.}\PYG{n}{sum}\PYG{p}{(}\PYG{n}{axis}\PYG{o}{=}\PYG{n}{i}\PYG{p}{,} \PYG{n}{keepdims}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{)}

                \PYG{n}{b}\PYG{o}{.}\PYG{n}{backward}\PYG{p}{(}\PYG{n}{dy}\PYG{p}{,} \PYG{n}{y}\PYG{p}{)}


    \PYG{k}{class}\PYG{+w}{ }\PYG{n+nc}{Mean}\PYG{p}{(}\PYG{n}{TensorFunction}\PYG{p}{):}
\PYG{+w}{        }\PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}Mean operation}

\PYG{l+s+sd}{        Args:}
\PYG{l+s+sd}{            TensorFunction (\PYGZus{}type\PYGZus{}):}
\PYG{l+s+sd}{        \PYGZdq{}\PYGZdq{}\PYGZdq{}}

        \PYG{k}{def}\PYG{+w}{ }\PYG{n+nf}{forward}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{a}\PYG{p}{:} \PYG{n}{Tensor}\PYG{p}{)} \PYG{o}{\PYGZhy{}\PYGZgt{}} \PYG{n}{Tensor}\PYG{p}{:}
\PYG{+w}{            }\PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}Computes the mean of a 1D tensor}

\PYG{l+s+sd}{            Args:}
\PYG{l+s+sd}{                a (Tensor):}

\PYG{l+s+sd}{            Returnws:}
\PYG{l+s+sd}{                Tensor: mean of a}
\PYG{l+s+sd}{            \PYGZdq{}\PYGZdq{}\PYGZdq{}}
            \PYG{n}{new\PYGZus{}data} \PYG{o}{=} \PYG{n}{a}\PYG{o}{.}\PYG{n}{data}\PYG{o}{.}\PYG{n}{mean}\PYG{p}{()}

            \PYG{n}{requires\PYGZus{}grad} \PYG{o}{=} \PYG{n}{a}\PYG{o}{.}\PYG{n}{requires\PYGZus{}grad}

            \PYG{n}{y} \PYG{o}{=} \PYG{n}{Tensor}\PYG{p}{(}\PYG{n}{new\PYGZus{}data}\PYG{p}{,} \PYG{n}{requires\PYGZus{}grad}\PYG{o}{=}\PYG{n}{requires\PYGZus{}grad}\PYG{p}{,} \PYG{n}{operation}\PYG{o}{=}\PYG{n+nb+bp}{self}\PYG{p}{)}

            \PYG{k}{if} \PYG{n}{is\PYGZus{}grad\PYGZus{}enabled}\PYG{p}{():}
                \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{parents} \PYG{o}{=} \PYG{p}{(}\PYG{n}{a}\PYG{p}{,)}

                \PYG{n}{a}\PYG{o}{.}\PYG{n}{children}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{y}\PYG{p}{)}

                \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{\PYGZus{}cache} \PYG{o}{=} \PYG{p}{(}\PYG{n}{a}\PYG{p}{,)}

            \PYG{k}{return} \PYG{n}{y}

        \PYG{k}{def}\PYG{+w}{ }\PYG{n+nf}{backward}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{dy}\PYG{p}{:} \PYG{n}{np}\PYG{o}{.}\PYG{n}{ndarray}\PYG{p}{,} \PYG{n}{y}\PYG{p}{:} \PYG{n}{Tensor}\PYG{p}{)} \PYG{o}{\PYGZhy{}\PYGZgt{}} \PYG{k+kc}{None}\PYG{p}{:}
\PYG{+w}{            }\PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}Computes gradients of cached tensors}

\PYG{l+s+sd}{            Args:}
\PYG{l+s+sd}{                dy (Tensor):}
\PYG{l+s+sd}{                y (Tensor):}
\PYG{l+s+sd}{            \PYGZdq{}\PYGZdq{}\PYGZdq{}}
            \PYG{p}{(}\PYG{n}{a}\PYG{p}{,)} \PYG{o}{=} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{\PYGZus{}cache}

            \PYG{k}{if} \PYG{n}{a}\PYG{o}{.}\PYG{n}{requires\PYGZus{}grad}\PYG{p}{:}
                \PYG{n}{da} \PYG{o}{=} \PYG{n}{dy} \PYG{o}{*} \PYG{n}{np}\PYG{o}{.}\PYG{n}{ones}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{a}\PYG{o}{.}\PYG{n}{data}\PYG{p}{))}
                \PYG{n}{da} \PYG{o}{/=} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{a}\PYG{o}{.}\PYG{n}{data}\PYG{p}{)}

                \PYG{n}{a}\PYG{o}{.}\PYG{n}{backward}\PYG{p}{(}\PYG{n}{da}\PYG{p}{,} \PYG{n}{y}\PYG{p}{)}


    \PYG{k}{class}\PYG{+w}{ }\PYG{n+nc}{Sum}\PYG{p}{(}\PYG{n}{TensorFunction}\PYG{p}{):}
\PYG{+w}{        }\PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}Sum of a tensor}

\PYG{l+s+sd}{        Args:}
\PYG{l+s+sd}{            TensorFunction (\PYGZus{}type\PYGZus{}): \PYGZus{}description\PYGZus{}}
\PYG{l+s+sd}{        \PYGZdq{}\PYGZdq{}\PYGZdq{}}

        \PYG{k}{def}\PYG{+w}{ }\PYG{n+nf}{forward}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{a}\PYG{p}{:} \PYG{n}{Tensor}\PYG{p}{,} \PYG{n}{dim}\PYG{p}{:} \PYG{n+nb}{int}\PYG{p}{,} \PYG{n}{keepdims}\PYG{p}{:} \PYG{n+nb}{bool}\PYG{p}{)} \PYG{o}{\PYGZhy{}\PYGZgt{}} \PYG{n}{Tensor}\PYG{p}{:}
\PYG{+w}{            }\PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}Computes sum of a tensor}

\PYG{l+s+sd}{            Args:}
\PYG{l+s+sd}{                a (Tensor):}
\PYG{l+s+sd}{                axis (int): axis to take sum across}
\PYG{l+s+sd}{                keepdims (bool): keepdims maintains the number of dimensions}
\PYG{l+s+sd}{                \PYGZhy{} reduces summed axis to 1}

\PYG{l+s+sd}{            Returns:}
\PYG{l+s+sd}{                Tensor: \PYGZus{}description\PYGZus{}}
\PYG{l+s+sd}{            \PYGZdq{}\PYGZdq{}\PYGZdq{}}
            \PYG{n}{new\PYGZus{}data} \PYG{o}{=} \PYG{n}{a}\PYG{o}{.}\PYG{n}{data}\PYG{o}{.}\PYG{n}{sum}\PYG{p}{(}\PYG{n}{axis}\PYG{o}{=}\PYG{n}{dim}\PYG{p}{,} \PYG{n}{keepdims}\PYG{o}{=}\PYG{n}{keepdims}\PYG{p}{)}

            \PYG{n}{requires\PYGZus{}grad} \PYG{o}{=} \PYG{n}{a}\PYG{o}{.}\PYG{n}{requires\PYGZus{}grad}

            \PYG{n}{y} \PYG{o}{=} \PYG{n}{Tensor}\PYG{p}{(}\PYG{n}{new\PYGZus{}data}\PYG{p}{,} \PYG{n}{requires\PYGZus{}grad}\PYG{o}{=}\PYG{n}{requires\PYGZus{}grad}\PYG{p}{,} \PYG{n}{operation}\PYG{o}{=}\PYG{n+nb+bp}{self}\PYG{p}{)}

            \PYG{k}{if} \PYG{n}{is\PYGZus{}grad\PYGZus{}enabled}\PYG{p}{():}
                \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{parents} \PYG{o}{=} \PYG{p}{(}\PYG{n}{a}\PYG{p}{,)}

                \PYG{n}{a}\PYG{o}{.}\PYG{n}{children}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{y}\PYG{p}{)}

                \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{\PYGZus{}cache} \PYG{o}{=} \PYG{p}{(}\PYG{n}{a}\PYG{p}{,)}

            \PYG{k}{return} \PYG{n}{y}

        \PYG{k}{def}\PYG{+w}{ }\PYG{n+nf}{backward}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{dy}\PYG{p}{:} \PYG{n}{np}\PYG{o}{.}\PYG{n}{ndarray}\PYG{p}{,} \PYG{n}{y}\PYG{p}{:} \PYG{n}{Tensor}\PYG{p}{)} \PYG{o}{\PYGZhy{}\PYGZgt{}} \PYG{k+kc}{None}\PYG{p}{:}
\PYG{+w}{            }\PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}Computes gradients of sum function}

\PYG{l+s+sd}{            Args:}
\PYG{l+s+sd}{                dy (np.ndarray): gradient from upstream}
\PYG{l+s+sd}{                y (Tensor):}
\PYG{l+s+sd}{            \PYGZdq{}\PYGZdq{}\PYGZdq{}}
            \PYG{p}{(}\PYG{n}{a}\PYG{p}{,)} \PYG{o}{=} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{\PYGZus{}cache}

            \PYG{k}{if} \PYG{n}{a}\PYG{o}{.}\PYG{n}{requires\PYGZus{}grad}\PYG{p}{:}
                \PYG{n}{da} \PYG{o}{=} \PYG{n}{dy} \PYG{o}{*} \PYG{n}{np}\PYG{o}{.}\PYG{n}{ones}\PYG{p}{(}\PYG{n}{a}\PYG{o}{.}\PYG{n}{shape}\PYG{p}{)}
                \PYG{n}{a}\PYG{o}{.}\PYG{n}{backward}\PYG{p}{(}\PYG{n}{da}\PYG{p}{,} \PYG{n}{y}\PYG{p}{)}


    \PYG{k}{class}\PYG{+w}{ }\PYG{n+nc}{Log}\PYG{p}{(}\PYG{n}{TensorFunction}\PYG{p}{):}
\PYG{+w}{        }\PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}Log operation}

\PYG{l+s+sd}{        Args:}
\PYG{l+s+sd}{            TensorFunction (\PYGZus{}type\PYGZus{}): \PYGZus{}description\PYGZus{}}
\PYG{l+s+sd}{        \PYGZdq{}\PYGZdq{}\PYGZdq{}}

        \PYG{k}{def}\PYG{+w}{ }\PYG{n+nf}{forward}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{a}\PYG{p}{:} \PYG{n}{Tensor}\PYG{p}{)} \PYG{o}{\PYGZhy{}\PYGZgt{}} \PYG{n}{Tensor}\PYG{p}{:}
\PYG{+w}{            }\PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}Element wise log of a tensor}

\PYG{l+s+sd}{            Args:}
\PYG{l+s+sd}{                a (Tensor):}

\PYG{l+s+sd}{            Returns:}
\PYG{l+s+sd}{                Tensor:}
\PYG{l+s+sd}{            \PYGZdq{}\PYGZdq{}\PYGZdq{}}

            \PYG{n}{new\PYGZus{}data} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{log}\PYG{p}{(}\PYG{n}{a}\PYG{o}{.}\PYG{n}{data}\PYG{p}{)}

            \PYG{n}{requires\PYGZus{}grad} \PYG{o}{=} \PYG{n}{a}\PYG{o}{.}\PYG{n}{requires\PYGZus{}grad}

            \PYG{n}{y} \PYG{o}{=} \PYG{n}{Tensor}\PYG{p}{(}\PYG{n}{new\PYGZus{}data}\PYG{p}{,} \PYG{n}{requires\PYGZus{}grad}\PYG{o}{=}\PYG{n}{requires\PYGZus{}grad}\PYG{p}{,} \PYG{n}{operation}\PYG{o}{=}\PYG{n+nb+bp}{self}\PYG{p}{)}

            \PYG{k}{if} \PYG{n}{is\PYGZus{}grad\PYGZus{}enabled}\PYG{p}{():}
                \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{parents} \PYG{o}{=} \PYG{p}{(}\PYG{n}{a}\PYG{p}{,)}

                \PYG{n}{a}\PYG{o}{.}\PYG{n}{children}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{y}\PYG{p}{)}

                \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{\PYGZus{}cache} \PYG{o}{=} \PYG{p}{(}\PYG{n}{a}\PYG{p}{,)}

            \PYG{k}{return} \PYG{n}{y}

        \PYG{k}{def}\PYG{+w}{ }\PYG{n+nf}{backward}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{dy}\PYG{p}{:} \PYG{n}{np}\PYG{o}{.}\PYG{n}{ndarray}\PYG{p}{,} \PYG{n}{y}\PYG{p}{:} \PYG{n}{Tensor}\PYG{p}{)} \PYG{o}{\PYGZhy{}\PYGZgt{}} \PYG{k+kc}{None}\PYG{p}{:}
\PYG{+w}{            }\PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}Computes gradient of cached tensor}

\PYG{l+s+sd}{            Args:}
\PYG{l+s+sd}{                dy (np.ndarray): gradient from upstream}
\PYG{l+s+sd}{                y (Tensor):}
\PYG{l+s+sd}{            \PYGZdq{}\PYGZdq{}\PYGZdq{}}
            \PYG{p}{(}\PYG{n}{a}\PYG{p}{,)} \PYG{o}{=} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{\PYGZus{}cache}
            \PYG{k}{if} \PYG{n}{a}\PYG{o}{.}\PYG{n}{requires\PYGZus{}grad}\PYG{p}{:}
                \PYG{n}{da} \PYG{o}{=} \PYG{n}{dy} \PYG{o}{*} \PYG{p}{(}\PYG{l+m+mi}{1} \PYG{o}{/} \PYG{n}{a}\PYG{o}{.}\PYG{n}{data}\PYG{p}{)}

                \PYG{n}{a}\PYG{o}{.}\PYG{n}{backward}\PYG{p}{(}\PYG{n}{da}\PYG{p}{,} \PYG{n}{y}\PYG{p}{)}


    \PYG{k}{class}\PYG{+w}{ }\PYG{n+nc}{Exp}\PYG{p}{(}\PYG{n}{TensorFunction}\PYG{p}{):}
\PYG{+w}{        }\PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}e\PYGZca{}}

\PYG{l+s+sd}{        Args:}
\PYG{l+s+sd}{            TensorFunction (\PYGZus{}type\PYGZus{}):}
\PYG{l+s+sd}{        \PYGZdq{}\PYGZdq{}\PYGZdq{}}

        \PYG{k}{def}\PYG{+w}{ }\PYG{n+nf}{forward}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{a}\PYG{p}{:} \PYG{n}{Tensor}\PYG{p}{)} \PYG{o}{\PYGZhy{}\PYGZgt{}} \PYG{n}{Tensor}\PYG{p}{:}
\PYG{+w}{            }\PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}e\PYGZca{}a}

\PYG{l+s+sd}{            Args:}
\PYG{l+s+sd}{                a (Tensor):}

\PYG{l+s+sd}{            Returns:}
\PYG{l+s+sd}{                Tensor:}
\PYG{l+s+sd}{            \PYGZdq{}\PYGZdq{}\PYGZdq{}}
            \PYG{n}{new\PYGZus{}data} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{exp}\PYG{p}{(}\PYG{n}{a}\PYG{o}{.}\PYG{n}{data}\PYG{p}{)}

            \PYG{n}{requires\PYGZus{}grad} \PYG{o}{=} \PYG{n}{a}\PYG{o}{.}\PYG{n}{requires\PYGZus{}grad}

            \PYG{n}{y} \PYG{o}{=} \PYG{n}{Tensor}\PYG{p}{(}\PYG{n}{new\PYGZus{}data}\PYG{p}{,} \PYG{n}{requires\PYGZus{}grad}\PYG{o}{=}\PYG{n}{requires\PYGZus{}grad}\PYG{p}{,} \PYG{n}{operation}\PYG{o}{=}\PYG{n+nb+bp}{self}\PYG{p}{)}

            \PYG{k}{if} \PYG{n}{is\PYGZus{}grad\PYGZus{}enabled}\PYG{p}{():}
                \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{parents} \PYG{o}{=} \PYG{p}{(}\PYG{n}{a}\PYG{p}{,)}

                \PYG{n}{a}\PYG{o}{.}\PYG{n}{children}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{y}\PYG{p}{)}

                \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{\PYGZus{}cache} \PYG{o}{=} \PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{new\PYGZus{}data}\PYG{p}{)}

            \PYG{k}{return} \PYG{n}{y}

        \PYG{k}{def}\PYG{+w}{ }\PYG{n+nf}{backward}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{dy}\PYG{p}{:} \PYG{n}{np}\PYG{o}{.}\PYG{n}{ndarray}\PYG{p}{,} \PYG{n}{y}\PYG{p}{:} \PYG{n}{Tensor}\PYG{p}{)} \PYG{o}{\PYGZhy{}\PYGZgt{}} \PYG{k+kc}{None}\PYG{p}{:}
\PYG{+w}{            }\PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}Computes grads}

\PYG{l+s+sd}{            Args:}
\PYG{l+s+sd}{                dy (np.ndarray):}
\PYG{l+s+sd}{                y (Tensor):}
\PYG{l+s+sd}{            \PYGZdq{}\PYGZdq{}\PYGZdq{}}
            \PYG{n}{a}\PYG{p}{,} \PYG{n}{new\PYGZus{}data} \PYG{o}{=} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{\PYGZus{}cache}

            \PYG{k}{if} \PYG{n}{a}\PYG{o}{.}\PYG{n}{requires\PYGZus{}grad}\PYG{p}{:}
                \PYG{n}{da} \PYG{o}{=} \PYG{n}{dy} \PYG{o}{*} \PYG{n}{new\PYGZus{}data}
                \PYG{n}{a}\PYG{o}{.}\PYG{n}{backward}\PYG{p}{(}\PYG{n}{da}\PYG{p}{,} \PYG{n}{y}\PYG{p}{)}


    \PYG{k}{class}\PYG{+w}{ }\PYG{n+nc}{Transpose}\PYG{p}{(}\PYG{n}{TensorFunction}\PYG{p}{):}
        \PYG{k}{def}\PYG{+w}{ }\PYG{n+nf}{forward}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{a}\PYG{p}{:} \PYG{n}{Tensor}\PYG{p}{)} \PYG{o}{\PYGZhy{}\PYGZgt{}} \PYG{n}{Tensor}\PYG{p}{:}
\PYG{+w}{            }\PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}Transposes the data}

\PYG{l+s+sd}{            Args:}
\PYG{l+s+sd}{                x (Tensor):}

\PYG{l+s+sd}{            Returns:}
\PYG{l+s+sd}{                Tensor:}
\PYG{l+s+sd}{            \PYGZdq{}\PYGZdq{}\PYGZdq{}}
            \PYG{n}{new\PYGZus{}data} \PYG{o}{=} \PYG{n}{a}\PYG{o}{.}\PYG{n}{data}\PYG{o}{.}\PYG{n}{T}

            \PYG{n}{requires\PYGZus{}grad} \PYG{o}{=} \PYG{n}{a}\PYG{o}{.}\PYG{n}{requires\PYGZus{}grad}

            \PYG{n}{y} \PYG{o}{=} \PYG{n}{Tensor}\PYG{p}{(}\PYG{n}{new\PYGZus{}data}\PYG{p}{,} \PYG{n}{requires\PYGZus{}grad}\PYG{o}{=}\PYG{n}{requires\PYGZus{}grad}\PYG{p}{,} \PYG{n}{operation}\PYG{o}{=}\PYG{n+nb+bp}{self}\PYG{p}{)}

            \PYG{k}{if} \PYG{n}{is\PYGZus{}grad\PYGZus{}enabled}\PYG{p}{():}
                \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{parents} \PYG{o}{=} \PYG{p}{(}\PYG{n}{a}\PYG{p}{,)}

                \PYG{n}{a}\PYG{o}{.}\PYG{n}{children}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{y}\PYG{p}{)}

                \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{\PYGZus{}cache} \PYG{o}{=} \PYG{p}{(}\PYG{n}{a}\PYG{p}{,)}

            \PYG{k}{return} \PYG{n}{y}

        \PYG{k}{def}\PYG{+w}{ }\PYG{n+nf}{backward}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{dy}\PYG{p}{:} \PYG{n}{np}\PYG{o}{.}\PYG{n}{ndarray}\PYG{p}{,} \PYG{n}{y}\PYG{p}{:} \PYG{n}{Tensor}\PYG{p}{)} \PYG{o}{\PYGZhy{}\PYGZgt{}} \PYG{k+kc}{None}\PYG{p}{:}
            \PYG{p}{(}\PYG{n}{a}\PYG{p}{,)} \PYG{o}{=} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{\PYGZus{}cache}

            \PYG{k}{if} \PYG{n}{a}\PYG{o}{.}\PYG{n}{requires\PYGZus{}grad}\PYG{p}{:}
                \PYG{n}{da} \PYG{o}{=} \PYG{n}{dy}\PYG{o}{.}\PYG{n}{T}

                \PYG{n}{a}\PYG{o}{.}\PYG{n}{backward}\PYG{p}{(}\PYG{n}{da}\PYG{p}{,} \PYG{n}{y}\PYG{p}{)}


    \PYG{k}{class}\PYG{+w}{ }\PYG{n+nc}{Convolve2D}\PYG{p}{(}\PYG{n}{TensorFunction}\PYG{p}{):}
\PYG{+w}{        }\PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}2D convolution layer as tensor function}

\PYG{l+s+sd}{        Args:}
\PYG{l+s+sd}{            TensorFunction (\PYGZus{}type\PYGZus{}):}
\PYG{l+s+sd}{        \PYGZdq{}\PYGZdq{}\PYGZdq{}}

        \PYG{k}{def}\PYG{+w}{ }\PYG{n+nf}{forward}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{x}\PYG{p}{:} \PYG{n}{Tensor}\PYG{p}{,} \PYG{n}{k}\PYG{p}{:} \PYG{n}{Tensor}\PYG{p}{,} \PYG{n}{b}\PYG{p}{:} \PYG{n}{Tensor} \PYG{o}{=} \PYG{k+kc}{None}\PYG{p}{)} \PYG{o}{\PYGZhy{}\PYGZgt{}} \PYG{n}{Tensor}\PYG{p}{:}
\PYG{+w}{            }\PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}2D Convolution layer of X as input}

\PYG{l+s+sd}{            Args:}
\PYG{l+s+sd}{                x (Tensor): Input to layer}
\PYG{l+s+sd}{            \PYGZdq{}\PYGZdq{}\PYGZdq{}}
            \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{n\PYGZus{}kernels}\PYG{p}{,} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{x\PYGZus{}samples}\PYG{p}{,} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{kernel\PYGZus{}size}\PYG{p}{,} \PYG{n}{\PYGZus{}} \PYG{o}{=} \PYG{n}{k}\PYG{o}{.}\PYG{n}{shape}
            \PYG{n}{x\PYGZus{}samples}\PYG{p}{,} \PYG{n}{x\PYGZus{}width}\PYG{p}{,} \PYG{n}{x\PYGZus{}height} \PYG{o}{=} \PYG{n}{x}\PYG{o}{.}\PYG{n}{shape}

            \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{output\PYGZus{}shape} \PYG{o}{=} \PYG{p}{(}
                \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{n\PYGZus{}kernels}\PYG{p}{,}
                \PYG{n}{x\PYGZus{}width} \PYG{o}{\PYGZhy{}} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{kernel\PYGZus{}size} \PYG{o}{+} \PYG{l+m+mi}{1}\PYG{p}{,}
                \PYG{n}{x\PYGZus{}height} \PYG{o}{\PYGZhy{}} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{kernel\PYGZus{}size} \PYG{o}{+} \PYG{l+m+mi}{1}\PYG{p}{,}
            \PYG{p}{)}

            \PYG{n}{new\PYGZus{}data} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{zeros}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{output\PYGZus{}shape}\PYG{p}{)}
            \PYG{k}{if} \PYG{n}{b}\PYG{p}{:}
                \PYG{n}{new\PYGZus{}data} \PYG{o}{+=} \PYG{n}{b}\PYG{o}{.}\PYG{n}{data}

            \PYG{n}{new\PYGZus{}data} \PYG{o}{=} \PYG{n}{cpu\PYGZus{}forward\PYGZus{}convolve2d}\PYG{p}{(}\PYG{n}{new\PYGZus{}data}\PYG{p}{,} \PYG{n}{x}\PYG{o}{.}\PYG{n}{data}\PYG{p}{,} \PYG{n}{k}\PYG{o}{.}\PYG{n}{data}\PYG{p}{,} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{n\PYGZus{}kernels}\PYG{p}{)}

            \PYG{n}{y} \PYG{o}{=} \PYG{n}{Tensor}\PYG{p}{(}\PYG{n}{new\PYGZus{}data}\PYG{p}{,} \PYG{n}{requires\PYGZus{}grad}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{,} \PYG{n}{operation}\PYG{o}{=}\PYG{n+nb+bp}{self}\PYG{p}{)}

            \PYG{k}{if} \PYG{n}{is\PYGZus{}grad\PYGZus{}enabled}\PYG{p}{():}
                \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{parents} \PYG{o}{=} \PYG{p}{[}
                    \PYG{n}{x}\PYG{p}{,}
                    \PYG{n}{k}\PYG{p}{,}
                \PYG{p}{]}
                \PYG{k}{if} \PYG{n}{b}\PYG{p}{:}
                    \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{parents}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{b}\PYG{p}{)}

                \PYG{n}{x}\PYG{o}{.}\PYG{n}{children}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{y}\PYG{p}{)}
                \PYG{n}{k}\PYG{o}{.}\PYG{n}{children}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{y}\PYG{p}{)}
                \PYG{k}{if} \PYG{n}{b}\PYG{p}{:}
                    \PYG{n}{b}\PYG{o}{.}\PYG{n}{children}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{y}\PYG{p}{)}

                \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{\PYGZus{}cache} \PYG{o}{=} \PYG{p}{(}\PYG{n}{x}\PYG{p}{,} \PYG{n}{k}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}

            \PYG{k}{return} \PYG{n}{y}

        \PYG{k}{def}\PYG{+w}{ }\PYG{n+nf}{backward}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{dy}\PYG{p}{:} \PYG{n}{np}\PYG{o}{.}\PYG{n}{ndarray}\PYG{p}{,} \PYG{n}{y}\PYG{p}{:} \PYG{n}{Tensor}\PYG{p}{)} \PYG{o}{\PYGZhy{}\PYGZgt{}} \PYG{k+kc}{None}\PYG{p}{:}
\PYG{+w}{            }\PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}Computes gradients of a convolutional layer process}

\PYG{l+s+sd}{            Args:}
\PYG{l+s+sd}{                dy (np.ndarray): upstream grad}
\PYG{l+s+sd}{                y (Tensor):}
\PYG{l+s+sd}{            \PYGZdq{}\PYGZdq{}\PYGZdq{}}
            \PYG{n}{x}\PYG{p}{,} \PYG{n}{k}\PYG{p}{,} \PYG{n}{b} \PYG{o}{=} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{\PYGZus{}cache}

            \PYG{k}{if} \PYG{n}{b}\PYG{p}{:}
                \PYG{k}{if} \PYG{n}{b}\PYG{o}{.}\PYG{n}{requires\PYGZus{}grad}\PYG{p}{:}
                    \PYG{n}{b}\PYG{o}{.}\PYG{n}{backward}\PYG{p}{(}\PYG{n}{dy}\PYG{p}{,} \PYG{n}{y}\PYG{p}{)}
            \PYG{k}{if} \PYG{n}{x}\PYG{o}{.}\PYG{n}{requires\PYGZus{}grad} \PYG{o+ow}{and} \PYG{n}{k}\PYG{o}{.}\PYG{n}{requires\PYGZus{}grad}\PYG{p}{:}
                \PYG{n}{dx} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{zeros}\PYG{p}{(}\PYG{n}{x}\PYG{o}{.}\PYG{n}{shape}\PYG{p}{)}
                \PYG{n}{dk} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{zeros}\PYG{p}{(}\PYG{n}{k}\PYG{o}{.}\PYG{n}{shape}\PYG{p}{)}
                \PYG{n}{dx}\PYG{p}{,} \PYG{n}{dk} \PYG{o}{=} \PYG{n}{cpu\PYGZus{}x\PYGZus{}and\PYGZus{}k\PYGZus{}backward\PYGZus{}convolve2d}\PYG{p}{(}
                    \PYG{n}{dx}\PYG{p}{,} \PYG{n}{dk}\PYG{p}{,} \PYG{n}{x}\PYG{o}{.}\PYG{n}{data}\PYG{p}{,} \PYG{n}{k}\PYG{o}{.}\PYG{n}{data}\PYG{p}{,} \PYG{n}{dy}\PYG{p}{,} \PYG{n}{x}\PYG{o}{.}\PYG{n}{shape}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{],} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{n\PYGZus{}kernels}
                \PYG{p}{)}

                \PYG{n}{x}\PYG{o}{.}\PYG{n}{backward}\PYG{p}{(}\PYG{n}{dx}\PYG{p}{,} \PYG{n}{y}\PYG{p}{)}
                \PYG{n}{k}\PYG{o}{.}\PYG{n}{backward}\PYG{p}{(}\PYG{n}{dk}\PYG{p}{,} \PYG{n}{y}\PYG{p}{)}
            \PYG{k}{else}\PYG{p}{:}
                \PYG{k}{if} \PYG{n}{x}\PYG{o}{.}\PYG{n}{requires\PYGZus{}grad}\PYG{p}{:}
                    \PYG{n}{dx} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{zeros}\PYG{p}{(}\PYG{n}{x}\PYG{o}{.}\PYG{n}{shape}\PYG{p}{)}
                    \PYG{n}{dx} \PYG{o}{=} \PYG{n}{cpu\PYGZus{}x\PYGZus{}backward\PYGZus{}convolve2d}\PYG{p}{(}
                        \PYG{n}{dx}\PYG{p}{,} \PYG{n}{k}\PYG{o}{.}\PYG{n}{data}\PYG{p}{,} \PYG{n}{dy}\PYG{p}{,} \PYG{n}{x}\PYG{o}{.}\PYG{n}{shape}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{],} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{n\PYGZus{}kernels}
                    \PYG{p}{)}

                    \PYG{n}{x}\PYG{o}{.}\PYG{n}{backward}\PYG{p}{(}\PYG{n}{dx}\PYG{p}{,} \PYG{n}{y}\PYG{p}{)}

                \PYG{k}{if} \PYG{n}{k}\PYG{o}{.}\PYG{n}{requires\PYGZus{}grad}\PYG{p}{:}
                    \PYG{n}{dk} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{zeros}\PYG{p}{(}\PYG{n}{k}\PYG{o}{.}\PYG{n}{shape}\PYG{p}{)}
                    \PYG{n}{dk} \PYG{o}{=} \PYG{n}{cpu\PYGZus{}k\PYGZus{}backward\PYGZus{}convolve2d}\PYG{p}{(}\PYG{n}{dk}\PYG{p}{,} \PYG{n}{x}\PYG{o}{.}\PYG{n}{data}\PYG{p}{,} \PYG{n}{dy}\PYG{p}{,} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{n\PYGZus{}kernels}\PYG{p}{)}

                    \PYG{n}{k}\PYG{o}{.}\PYG{n}{backward}\PYG{p}{(}\PYG{n}{dk}\PYG{p}{,} \PYG{n}{y}\PYG{p}{)}


    \PYG{k}{class}\PYG{+w}{ }\PYG{n+nc}{Reshape}\PYG{p}{(}\PYG{n}{TensorFunction}\PYG{p}{):}
\PYG{+w}{        }\PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}Reshapes a tensor}

\PYG{l+s+sd}{        Args:}
\PYG{l+s+sd}{            TensorFunction :}
\PYG{l+s+sd}{        \PYGZdq{}\PYGZdq{}\PYGZdq{}}

        \PYG{k}{def}\PYG{+w}{ }\PYG{n+nf}{forward}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{a}\PYG{p}{:} \PYG{n}{Tensor}\PYG{p}{,} \PYG{n}{shape}\PYG{p}{:} \PYG{n+nb}{tuple}\PYG{p}{[}\PYG{n+nb}{int}\PYG{p}{])} \PYG{o}{\PYGZhy{}\PYGZgt{}} \PYG{n}{Tensor}\PYG{p}{:}
\PYG{+w}{            }\PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}Reshapes the tensor}

\PYG{l+s+sd}{            Args:}
\PYG{l+s+sd}{                x (Tensor): tensor to reshape}

\PYG{l+s+sd}{            Returns:}
\PYG{l+s+sd}{                Tensor: reshaped tensor}
\PYG{l+s+sd}{            \PYGZdq{}\PYGZdq{}\PYGZdq{}}
            \PYG{n}{new\PYGZus{}data} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{reshape}\PYG{p}{(}\PYG{n}{a}\PYG{o}{.}\PYG{n}{data}\PYG{p}{,} \PYG{n}{shape}\PYG{p}{)}

            \PYG{n}{y} \PYG{o}{=} \PYG{n}{Tensor}\PYG{p}{(}\PYG{n}{new\PYGZus{}data}\PYG{p}{,} \PYG{n}{requires\PYGZus{}grad}\PYG{o}{=}\PYG{n}{a}\PYG{o}{.}\PYG{n}{requires\PYGZus{}grad}\PYG{p}{,} \PYG{n}{operation}\PYG{o}{=}\PYG{n+nb+bp}{self}\PYG{p}{)}

            \PYG{k}{if} \PYG{n}{is\PYGZus{}grad\PYGZus{}enabled}\PYG{p}{():}
                \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{parents} \PYG{o}{=} \PYG{p}{(}\PYG{n}{a}\PYG{p}{,)}

                \PYG{n}{a}\PYG{o}{.}\PYG{n}{children}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{y}\PYG{p}{)}

                \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{\PYGZus{}cache} \PYG{o}{=} \PYG{p}{(}\PYG{n}{a}\PYG{p}{,)}

            \PYG{k}{return} \PYG{n}{y}

        \PYG{k}{def}\PYG{+w}{ }\PYG{n+nf}{backward}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{dy}\PYG{p}{:} \PYG{n}{np}\PYG{o}{.}\PYG{n}{ndarray}\PYG{p}{,} \PYG{n}{y}\PYG{p}{:} \PYG{n}{Tensor}\PYG{p}{)} \PYG{o}{\PYGZhy{}\PYGZgt{}} \PYG{k+kc}{None}\PYG{p}{:}
            \PYG{p}{(}\PYG{n}{a}\PYG{p}{,)} \PYG{o}{=} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{\PYGZus{}cache}

            \PYG{k}{if} \PYG{n}{a}\PYG{o}{.}\PYG{n}{requires\PYGZus{}grad}\PYG{p}{:}
                \PYG{n}{da} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{reshape}\PYG{p}{(}\PYG{n}{dy}\PYG{p}{,} \PYG{n}{a}\PYG{o}{.}\PYG{n}{shape}\PYG{p}{)}
                \PYG{n}{a}\PYG{o}{.}\PYG{n}{backward}\PYG{p}{(}\PYG{n}{da}\PYG{p}{,} \PYG{n}{y}\PYG{p}{)}


    \PYG{k}{class}\PYG{+w}{ }\PYG{n+nc}{Pad2D}\PYG{p}{(}\PYG{n}{TensorFunction}\PYG{p}{):}
        \PYG{k}{def}\PYG{+w}{ }\PYG{n+nf}{forward}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{a}\PYG{p}{:} \PYG{n}{Tensor}\PYG{p}{,} \PYG{n}{padding}\PYG{p}{:} \PYG{n+nb}{int}\PYG{p}{,} \PYG{n}{value}\PYG{p}{:} \PYG{n+nb}{float}\PYG{p}{)} \PYG{o}{\PYGZhy{}\PYGZgt{}} \PYG{n}{Tensor}\PYG{p}{:}
            \PYG{n}{a\PYGZus{}samples}\PYG{p}{,} \PYG{n}{a\PYGZus{}rows}\PYG{p}{,} \PYG{n}{a\PYGZus{}cols} \PYG{o}{=} \PYG{n}{a}\PYG{o}{.}\PYG{n}{shape}

            \PYG{n}{new\PYGZus{}rows} \PYG{o}{=} \PYG{n}{a\PYGZus{}rows} \PYG{o}{+} \PYG{l+m+mi}{2} \PYG{o}{*} \PYG{n}{padding}
            \PYG{n}{new\PYGZus{}cols} \PYG{o}{=} \PYG{n}{a\PYGZus{}cols} \PYG{o}{+} \PYG{l+m+mi}{2} \PYG{o}{*} \PYG{n}{padding}

            \PYG{n}{arr} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{full}\PYG{p}{((}\PYG{n}{a\PYGZus{}samples}\PYG{p}{,} \PYG{n}{new\PYGZus{}rows}\PYG{p}{,} \PYG{n}{new\PYGZus{}cols}\PYG{p}{),} \PYG{n}{fill\PYGZus{}value}\PYG{o}{=}\PYG{n}{value}\PYG{p}{)}

            \PYG{n}{arr} \PYG{o}{=} \PYG{n}{fill\PYGZus{}padded\PYGZus{}array}\PYG{p}{(}\PYG{n}{arr}\PYG{p}{,} \PYG{n}{a}\PYG{o}{.}\PYG{n}{data}\PYG{p}{,} \PYG{n}{padding}\PYG{p}{)}

            \PYG{n}{y} \PYG{o}{=} \PYG{n}{Tensor}\PYG{p}{(}\PYG{n}{arr}\PYG{p}{,} \PYG{n}{a}\PYG{o}{.}\PYG{n}{requires\PYGZus{}grad}\PYG{p}{,} \PYG{n}{operation}\PYG{o}{=}\PYG{n+nb+bp}{self}\PYG{p}{)}

            \PYG{k}{if} \PYG{n}{is\PYGZus{}grad\PYGZus{}enabled}\PYG{p}{():}
                \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{parents} \PYG{o}{=} \PYG{p}{(}\PYG{n}{a}\PYG{p}{,)}

                \PYG{n}{a}\PYG{o}{.}\PYG{n}{children}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{y}\PYG{p}{)}

                \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{\PYGZus{}cache} \PYG{o}{=} \PYG{p}{(}
                    \PYG{n}{a}\PYG{p}{,}
                    \PYG{n}{padding}\PYG{p}{,}
                \PYG{p}{)}

            \PYG{k}{return} \PYG{n}{y}

        \PYG{k}{def}\PYG{+w}{ }\PYG{n+nf}{backward}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{dy}\PYG{p}{:} \PYG{n}{np}\PYG{o}{.}\PYG{n}{ndarray}\PYG{p}{,} \PYG{n}{y}\PYG{p}{:} \PYG{n}{Tensor}\PYG{p}{)} \PYG{o}{\PYGZhy{}\PYGZgt{}} \PYG{k+kc}{None}\PYG{p}{:}
            \PYG{p}{(}
                \PYG{n}{a}\PYG{p}{,}
                \PYG{n}{padding}\PYG{p}{,}
            \PYG{p}{)} \PYG{o}{=} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{\PYGZus{}cache}

            \PYG{k}{if} \PYG{n}{a}\PYG{o}{.}\PYG{n}{requires\PYGZus{}grad}\PYG{p}{:}
                \PYG{k}{if} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{dy}\PYG{o}{.}\PYG{n}{shape}\PYG{p}{)} \PYG{o}{==} \PYG{l+m+mi}{3}\PYG{p}{:}
                    \PYG{n}{da} \PYG{o}{=} \PYG{n}{dy}\PYG{p}{[:,} \PYG{n}{padding}\PYG{p}{:}\PYG{o}{\PYGZhy{}}\PYG{n}{padding}\PYG{p}{,} \PYG{n}{padding}\PYG{p}{:}\PYG{o}{\PYGZhy{}}\PYG{n}{padding}\PYG{p}{]}
                \PYG{k}{elif} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{dy}\PYG{o}{.}\PYG{n}{shape}\PYG{p}{)} \PYG{o}{==} \PYG{l+m+mi}{3}\PYG{p}{:}
                    \PYG{n}{da} \PYG{o}{=} \PYG{n}{dy}\PYG{p}{[}\PYG{n}{padding}\PYG{p}{:}\PYG{o}{\PYGZhy{}}\PYG{n}{padding}\PYG{p}{,} \PYG{n}{padding}\PYG{p}{:}\PYG{o}{\PYGZhy{}}\PYG{n}{padding}\PYG{p}{]}
                \PYG{n}{a}\PYG{o}{.}\PYG{n}{backward}\PYG{p}{(}\PYG{n}{da}\PYG{p}{,} \PYG{n}{y}\PYG{p}{)}


    \PYG{k}{class}\PYG{+w}{ }\PYG{n+nc}{ReLU}\PYG{p}{(}\PYG{n}{TensorFunction}\PYG{p}{):}
        \PYG{k}{def}\PYG{+w}{ }\PYG{n+nf}{forward}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{a}\PYG{p}{:} \PYG{n}{Tensor}\PYG{p}{)} \PYG{o}{\PYGZhy{}\PYGZgt{}} \PYG{n}{Tensor}\PYG{p}{:}
\PYG{+w}{            }\PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}Specialised function for relu activation}

\PYG{l+s+sd}{            Args:}
\PYG{l+s+sd}{                a (Tensor):}

\PYG{l+s+sd}{            Returns:}
\PYG{l+s+sd}{                Tensor:}
\PYG{l+s+sd}{            \PYGZdq{}\PYGZdq{}\PYGZdq{}}
            \PYG{n}{new\PYGZus{}data} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{maximum}\PYG{p}{(}\PYG{l+m+mf}{0.0}\PYG{p}{,} \PYG{n}{a}\PYG{o}{.}\PYG{n}{data}\PYG{p}{)}

            \PYG{n}{y} \PYG{o}{=} \PYG{n}{Tensor}\PYG{p}{(}\PYG{n}{new\PYGZus{}data}\PYG{p}{,} \PYG{n}{requires\PYGZus{}grad}\PYG{o}{=}\PYG{n}{a}\PYG{o}{.}\PYG{n}{requires\PYGZus{}grad}\PYG{p}{,} \PYG{n}{operation}\PYG{o}{=}\PYG{n+nb+bp}{self}\PYG{p}{)}

            \PYG{k}{if} \PYG{n}{is\PYGZus{}grad\PYGZus{}enabled}\PYG{p}{():}
                \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{parents} \PYG{o}{=} \PYG{p}{(}\PYG{n}{a}\PYG{p}{,)}

                \PYG{n}{a}\PYG{o}{.}\PYG{n}{children}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{y}\PYG{p}{)}

                \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{\PYGZus{}cache} \PYG{o}{=} \PYG{p}{(}\PYG{n}{a}\PYG{p}{,)}

            \PYG{k}{return} \PYG{n}{y}

        \PYG{k}{def}\PYG{+w}{ }\PYG{n+nf}{backward}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{dy}\PYG{p}{:} \PYG{n}{np}\PYG{o}{.}\PYG{n}{ndarray}\PYG{p}{,} \PYG{n}{y}\PYG{p}{:} \PYG{n}{Tensor}\PYG{p}{)} \PYG{o}{\PYGZhy{}\PYGZgt{}} \PYG{k+kc}{None}\PYG{p}{:}
            \PYG{p}{(}\PYG{n}{a}\PYG{p}{,)} \PYG{o}{=} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{\PYGZus{}cache}

            \PYG{k}{if} \PYG{n}{a}\PYG{o}{.}\PYG{n}{requires\PYGZus{}grad}\PYG{p}{:}
                \PYG{n}{da} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{greater}\PYG{p}{(}\PYG{n}{dy}\PYG{p}{,} \PYG{l+m+mf}{0.0}\PYG{p}{)}\PYG{o}{.}\PYG{n}{astype}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{float64}\PYG{p}{)}
                \PYG{n}{a}\PYG{o}{.}\PYG{n}{backward}\PYG{p}{(}\PYG{n}{da}\PYG{p}{,} \PYG{n}{y}\PYG{p}{)}
\end{Verbatim}
